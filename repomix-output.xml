This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gitignore
apps/cli/Cargo.toml
apps/cli/src/main.rs
build_core_2.txt
build_core_3.txt
build_core_4.txt
build_core_5.txt
build_watcher.txt
Cargo.toml
crates/core/Cargo.toml
crates/core/src/ledger.rs
crates/core/src/lib.rs
crates/core/src/models.rs
crates/core/src/state.rs
crates/core/src/vfs.rs
crates/core/src/watcher.rs
deve-note plan.md
deve-note schedule.md
dump_hello.txt
dump.txt
scan.txt
verify_debug.txt
verify_final.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="apps/cli/Cargo.toml">
[package]
name = "deve_cli"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
deve_core.workspace = true
tokio.workspace = true
anyhow.workspace = true
tracing.workspace = true
tracing-subscriber.workspace = true
clap = { version = "4.4", features = ["derive"] }
</file>

<file path="apps/cli/src/main.rs">
use clap::{Parser, Subcommand};
use deve_core::ledger::Ledger;
use deve_core::vfs::Vfs;
use std::path::PathBuf;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand, Debug)]
enum Commands {
    /// Initialize a new Deve-Note vault
    Init {
        #[arg(short, long, default_value = ".")]
        path: PathBuf,
    },
    /// Scan and index the vault
    Scan,
    /// Watch the vault for changes
    Watch,
    /// Dump ops for a file
    Dump {
        #[arg(short, long)]
        path: String,
    },
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let args = Args::parse();
    
    // Initialize logging
    tracing_subscriber::fmt::init();

    // Default paths
    let ledger_path = PathBuf::from("deve.db");
    let vault_path = PathBuf::from("vault");

    match args.command {
        Some(Commands::Init { path }) => {
            println!("Initializing ledger at {:?}...", ledger_path);
            let _ = Ledger::init(&ledger_path)?;
            std::fs::create_dir_all(&vault_path)?;
            println!("Initialization complete.");
        }
        Some(Commands::Scan) => {
            let ledger = Ledger::init(&ledger_path)?;
            let vfs = Vfs::new(&vault_path);
            println!("Scanning vault at {:?}...", vault_path);
            let count = vfs.scan(&ledger)?;
            println!("Scanned. Registered {} new documents.", count);
        }
        Some(Commands::Watch) => {
            let ledger = Ledger::init(&ledger_path)?;
            let vfs = Vfs::new(&vault_path);
            let watcher = deve_core::watcher::Watcher::new(ledger, vfs);
            println!("Starting watcher on {:?}... Press Ctrl+C to stop.", vault_path);
            watcher.watch()?;
        }
        Some(Commands::Dump { path }) => {
            let ledger = Ledger::init(&ledger_path)?;
            if let Some(doc_id) = ledger.get_docid(&path)? {
                println!("DocId: {}", doc_id);
                let ops = ledger.get_ops(doc_id)?;
                println!("Found {} ops:", ops.len());
                for (i, entry) in ops.iter().enumerate() {
                    println!("[{}] {} {:?}", i, entry.timestamp, entry.op);
                }
                
                let content = deve_core::state::reconstruct_content(&ops);
                println!("\nReconstructed Content:\n---\n{}\n---", content);
            } else {
                println!("Path not found in Ledger.");
            }
        }
        None => {
            println!("Please provide a subcommand. Try --help.");
        }
    }

    Ok(())
}
</file>

<file path="build_core_2.txt">
Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
error[E0599]: no variant or associated item named `new` found for enum `FileId` in the current scope
   --> crates\core\src\vfs.rs:25:31
    |
 25 |         let file_id = FileId::new(&full_path)?;
    |                               ^^^ variant or associated item not found in `FileId`
    |
note: if you're trying to build a new `FileId` consider using one of the following associated functions:
      FileId::new_inode
      FileId::new_low_res
      FileId::new_high_res
   --> C:\Users\QQ\scoop\persist\rustup\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\file-id-0.2.3\src\lib.rs:87:5
    |
 87 |     pub fn new_inode(device_id: u64, inode_number: u64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 94 |     pub fn new_low_res(volume_serial_number: u32, file_index: u64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
101 |     pub fn new_high_res(volume_serial_number: u64, file_id: u128) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: there is a method `ne` with a similar name
    |
 25 -         let file_id = FileId::new(&full_path)?;
 25 +         let file_id = FileId::ne(&full_path)?;
    |

warning: unused variable: `doc_id`
  --> crates\core\src\watcher.rs:88:25
   |
88 |             if let Some(doc_id) = self.ledger.get_docid(path_str)? {
   |                         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_doc_id`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

For more information about this error, try `rustc --explain E0599`.
warning: `deve_core` (lib) generated 1 warning
error: could not compile `deve_core` (lib) due to 1 previous error; 1 warning emitted
</file>

<file path="build_core_3.txt">
Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
error[E0599]: no variant or associated item named `from_path` found for enum `FileId` in the current scope
   --> crates\core\src\vfs.rs:25:31
    |
 25 |         let file_id = FileId::from_path(&full_path)?;
    |                               ^^^^^^^^^ variant or associated item not found in `FileId`
    |
note: if you're trying to build a new `FileId` consider using one of the following associated functions:
      FileId::new_inode
      FileId::new_low_res
      FileId::new_high_res
   --> C:\Users\QQ\scoop\persist\rustup\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\file-id-0.2.3\src\lib.rs:87:5
    |
 87 |     pub fn new_inode(device_id: u64, inode_number: u64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
 94 |     pub fn new_low_res(volume_serial_number: u32, file_index: u64) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
...
101 |     pub fn new_high_res(volume_serial_number: u64, file_id: u128) -> Self {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For more information about this error, try `rustc --explain E0599`.
error: could not compile `deve_core` (lib) due to 1 previous error
</file>

<file path="build_core_4.txt">
Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
warning: unused import: `file_id::FileId`
 --> crates\core\src\vfs.rs:6:5
  |
6 | use file_id::FileId;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: `deve_core` (lib) generated 1 warning (run `cargo fix --lib -p deve_core` to apply 1 suggestion)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 1.24s
</file>

<file path="build_core_5.txt">
Compiling dissimilar v1.0.10
   Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
warning: unused import: `file_id::FileId`
 --> crates\core\src\vfs.rs:6:5
  |
6 | use file_id::FileId;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `anyhow::Result`
 --> crates\core\src\state.rs:2:5
  |
2 | use anyhow::Result;
  |     ^^^^^^^^^^^^^^

error[E0599]: no method named `value` found for enum `Result<T, E>` in the current scope
   --> crates\core\src\ledger.rs:151:31
    |
151 |             let seq_val = seq.value();
    |                               ^^^^^ method not found in `Result<AccessGuard<'_, u64>, StorageError>`
    |
note: the method `value` exists on the type `AccessGuard<'_, u64>`
   --> C:\Users\QQ\scoop\persist\rustup\.cargo\registry\src\index.crates.io-1949cf8c6b5b557f\redb-2.6.3\src\tree_store\btree_base.rs:227:5
    |
227 |     pub fn value(&self) -> V::SelfType<'_> {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
help: use the `?` operator to extract the `AccessGuard<'_, u64>` value, propagating a `Result::Err` value to the caller
    |
151 |             let seq_val = seq?.value();
    |                              +

error[E0308]: mismatched types
  --> crates\core\src\state.rs:25:40
   |
25 |                     content.drain(pos..end);
   |                                        ^^^ expected `&usize`, found `usize`
   |
help: consider borrowing here
   |
25 |                     content.drain(pos..&end);
   |                                        +

Some errors have detailed explanations: E0308, E0599.
For more information about an error, try `rustc --explain E0308`.
warning: `deve_core` (lib) generated 2 warnings
error: could not compile `deve_core` (lib) due to 2 previous errors; 2 warnings emitted
</file>

<file path="build_watcher.txt">
Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
warning: unused import: `anyhow`
 --> crates\core\src\watcher.rs:1:22
  |
1 | use anyhow::{Result, anyhow};
  |                      ^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `DebounceEventResult`
 --> crates\core\src\watcher.rs:2:67
  |
2 | use notify_debouncer_mini::{new_debouncer, notify::RecursiveMode, DebounceEventResult};
  |                                                                   ^^^^^^^^^^^^^^^^^^^

warning: unused import: `std::path::Path`
 --> crates\core\src\watcher.rs:3:5
  |
3 | use std::path::Path;
  |     ^^^^^^^^^^^^^^^

error[E0658]: use of unstable library feature `windows_by_handle`
  --> crates\core\src\vfs.rs:26:28
   |
26 |         let id_val = (meta.volume_serial_number() as u128) << 64 | (meta.file_index() as u128);
   |                            ^^^^^^^^^^^^^^^^^^^^
   |
   = note: see issue #63010 <https://github.com/rust-lang/rust/issues/63010> for more information

error[E0658]: use of unstable library feature `windows_by_handle`
  --> crates\core\src\vfs.rs:26:74
   |
26 |         let id_val = (meta.volume_serial_number() as u128) << 64 | (meta.file_index() as u128);
   |                                                                          ^^^^^^^^^^
   |
   = note: see issue #63010 <https://github.com/rust-lang/rust/issues/63010> for more information

error[E0605]: non-primitive cast: `std::option::Option<u32>` as `u128`
  --> crates\core\src\vfs.rs:26:22
   |
26 |         let id_val = (meta.volume_serial_number() as u128) << 64 | (meta.file_index() as u128);
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can be used to convert enum types to numeric types only if the enum type is unit-only or field-less
   |
   = note: see https://doc.rust-lang.org/reference/items/enumerations.html#casting for more information

error[E0605]: non-primitive cast: `std::option::Option<u64>` as `u128`
  --> crates\core\src\vfs.rs:26:68
   |
26 |         let id_val = (meta.volume_serial_number() as u128) << 64 | (meta.file_index() as u128);
   |                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can be used to convert enum types to numeric types only if the enum type is unit-only or field-less
   |
   = note: see https://doc.rust-lang.org/reference/items/enumerations.html#casting for more information

error[E0616]: field `root` of struct `Vfs` is private
  --> crates\core\src\watcher.rs:27:30
   |
27 |             .watch(&self.vfs.root, RecursiveMode::Recursive)?;
   |                              ^^^^ private field

error[E0616]: field `root` of struct `Vfs` is private
  --> crates\core\src\watcher.rs:29:51
   |
29 |         info!("Watcher started on {:?}", self.vfs.root);
   |                                                   ^^^^ private field

error[E0616]: field `root` of struct `Vfs` is private
  --> crates\core\src\watcher.rs:37:69
   |
37 |                        if let Ok(rel) = path.strip_prefix(&self.vfs.root) {
   |                                                                     ^^^^ private field

warning: unused variable: `doc_id`
  --> crates\core\src\watcher.rs:89:25
   |
89 |             if let Some(doc_id) = self.ledger.get_docid(path_str)? {
   |                         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_doc_id`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

Some errors have detailed explanations: E0605, E0616, E0658.
For more information about an error, try `rustc --explain E0605`.
warning: `deve_core` (lib) generated 4 warnings
error: could not compile `deve_core` (lib) due to 7 previous errors; 4 warnings emitted
</file>

<file path="Cargo.toml">
[workspace]
members = [
    "apps/cli",
    "crates/core",
]
resolver = "2"

[workspace.package]
version = "0.0.1"
edition = "2024"
authors = ["Deve-Note Contributors"]
license = "MIT"
repository = "https://github.com/develeta/deve-note"

[workspace.dependencies]
# Intra-workspace dependencies
deve_core = { path = "crates/core" }

# Common dependencies
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
anyhow = "1.0"
tracing = "0.1"
tracing-subscriber = "0.3"
tokio = { version = "1.0", features = ["full"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }

# Storage & CRDT
redb = "2.0"
# loro = "1.0" # TBD: Add Loro when we start implementing CRDT
</file>

<file path="crates/core/Cargo.toml">
[package]
name = "deve_core"
version.workspace = true
edition.workspace = true
authors.workspace = true
license.workspace = true

[dependencies]
serde.workspace = true
serde_json.workspace = true
thiserror.workspace = true
anyhow.workspace = true
tracing.workspace = true
uuid.workspace = true
chrono.workspace = true
redb.workspace = true
bincode = "1.3"
walkdir = "2.5.0"
notify = "8.2.0"
file-id = "0.2.3"
crossbeam-channel = "0.5.15"
notify-debouncer-mini = "0.7.0"
dissimilar = "1.0.10"
</file>

<file path="crates/core/src/ledger.rs">
use anyhow::Result;
use redb::{Database, TableDefinition, ReadableTable};
use std::path::Path;
use crate::models::{DocId, LedgerEntry, FileNodeId};

// Table Definitions
// DocId (u128) -> Path String
const DOCID_TO_PATH: TableDefinition<u128, &str> = TableDefinition::new("docid_to_path");
// Path String -> DocId (u128)
const PATH_TO_DOCID: TableDefinition<&str, u128> = TableDefinition::new("path_to_docid");
// FileNodeId (u128) -> DocId (u128) - For Rename Detection
const INODE_TO_DOCID: TableDefinition<u128, u128> = TableDefinition::new("inode_to_docid");
// Sequence (u64) -> LedgerEntry (Bytes)
const LEDGER_OPS: TableDefinition<u64, &[u8]> = TableDefinition::new("ledger_ops");
// DocId (u128) -> Vec<u64> (Sequence Numbers) - Secondary Index
// Simpler: Just scan LEDGER_OPS? No, that's O(N). We need an index.
// DocId + Seq -> ()?
// Let's use a MultiMap equivalent? Redb supports Multimap? 
// Redb 2.0 has MultimapTableDefinition.
use redb::MultimapTableDefinition;
const DOC_OPS: MultimapTableDefinition<u128, u64> = MultimapTableDefinition::new("doc_ops");

pub struct Ledger {
    db: Database,
}

impl Ledger {
    pub fn init(path: impl AsRef<Path>) -> Result<Self> {
        let db = Database::create(path)?;
        
        // Initialize tables
        let write_txn = db.begin_write()?;
        {
            let _ = write_txn.open_table(DOCID_TO_PATH)?;
            let _ = write_txn.open_table(PATH_TO_DOCID)?;
            let _ = write_txn.open_table(INODE_TO_DOCID)?;
            let _ = write_txn.open_table(LEDGER_OPS)?;
            let _ = write_txn.open_multimap_table(DOC_OPS)?;
        }
        write_txn.commit()?;

        Ok(Self { db })
    }

    pub fn get_docid(&self, path: &str) -> Result<Option<DocId>> {
        let read_txn = self.db.begin_read()?;
        let table = read_txn.open_table(PATH_TO_DOCID)?;
        if let Some(v) = table.get(path)? {
            Ok(Some(DocId::from_u128(v.value())))
        } else {
            Ok(None)
        }
    }

    pub fn create_docid(&self, path: &str) -> Result<DocId> {
        let id = DocId::new();
        let write_txn = self.db.begin_write()?;
        {
            let mut p2d = write_txn.open_table(PATH_TO_DOCID)?;
            let mut d2p = write_txn.open_table(DOCID_TO_PATH)?;
            
            p2d.insert(path, id.as_u128())?;
            d2p.insert(id.as_u128(), path)?;
        }
        write_txn.commit()?;
        Ok(id)
    }

    pub fn get_path_by_docid(&self, doc_id: DocId) -> Result<Option<String>> {
         let read_txn = self.db.begin_read()?;
         let table = read_txn.open_table(DOCID_TO_PATH)?;
         if let Some(v) = table.get(doc_id.as_u128())? {
             Ok(Some(v.value().to_string()))
         } else {
             Ok(None)
         }
    }

    pub fn get_docid_by_inode(&self, inode: &FileNodeId) -> Result<Option<DocId>> {
        let read_txn = self.db.begin_read()?;
        let table = read_txn.open_table(INODE_TO_DOCID)?;
        if let Some(v) = table.get(inode.id)? {
            Ok(Some(DocId::from_u128(v.value())))
        } else {
            Ok(None)
        }
    }

    pub fn bind_inode(&self, inode: &FileNodeId, doc_id: DocId) -> Result<()> {
        let write_txn = self.db.begin_write()?;
        {
            let mut table = write_txn.open_table(INODE_TO_DOCID)?;
            table.insert(inode.id, doc_id.as_u128())?;
        }
        write_txn.commit()?;
        Ok(())
    }

    pub fn rename_doc(&self, old_path: &str, new_path: &str) -> Result<()> {
        let write_txn = self.db.begin_write()?;
        {
            let mut p2d = write_txn.open_table(PATH_TO_DOCID)?;
            let mut d2p = write_txn.open_table(DOCID_TO_PATH)?;

            // Get ID
            // Get ID and drop the guard immediately
            let id_opt = p2d.get(old_path)?.map(|v| v.value());

            if let Some(id) = id_opt {
                // Remove old path mapping
                p2d.remove(old_path)?;
                // Insert new path mapping
                p2d.insert(new_path, id)?;
                // Update reverse mapping
                d2p.insert(id, new_path)?;
            }
        }
        write_txn.commit()?;
        Ok(())
    }

    pub fn append_op(&self, entry: &LedgerEntry) -> Result<u64> {
        let write_txn = self.db.begin_write()?;
        let seq = {
            let mut ops = write_txn.open_table(LEDGER_OPS)?;
            let mut doc_ops = write_txn.open_multimap_table(DOC_OPS)?;
            
            let last_seq = ops.last()?.map(|(k, _)| k.value()).unwrap_or(0u64);
            let new_seq = last_seq + 1;
            let bytes = bincode::serialize(entry)?;
            ops.insert(new_seq, bytes.as_slice())?;
            
            // Index by DocId
            doc_ops.insert(entry.doc_id.as_u128(), new_seq)?;
            
            new_seq
        };
        write_txn.commit()?;
        Ok(seq)
    }

    pub fn get_ops(&self, doc_id: DocId) -> Result<Vec<LedgerEntry>> {
        let read_txn = self.db.begin_read()?;
        let ops_table = read_txn.open_table(LEDGER_OPS)?;
        let doc_ops_table = read_txn.open_multimap_table(DOC_OPS)?;
        
        let mut entries = Vec::new();
        let seqs = doc_ops_table.get(doc_id.as_u128())?;
        
        for seq in seqs {
            let seq_val = seq?.value();
            if let Some(bytes) = ops_table.get(seq_val)? {
                 let entry: LedgerEntry = bincode::deserialize(bytes.value())?;
                 entries.push(entry);
            }
        }
        
        // Sort by timestamp or just trust insertion order (Sequence)?
        // Sequence is monotonic.
        Ok(entries)
    }
}
</file>

<file path="crates/core/src/lib.rs">
pub mod ledger;
pub mod models;
pub mod vfs;
pub mod watcher;
pub mod state;
</file>

<file path="crates/core/src/models.rs">
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use std::fmt;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct DocId(pub Uuid);

impl DocId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }

    pub fn from_u128(v: u128) -> Self {
        Self(Uuid::from_u128(v))
    }

    pub fn as_u128(&self) -> u128 {
        self.0.as_u128()
    }
}

impl fmt::Display for DocId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Op {
    Insert { pos: usize, content: String },
    Delete { pos: usize, len: usize },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LedgerEntry {
    pub doc_id: DocId, // We need to know which doc this Op belongs to!
    pub op: Op,
    pub timestamp: i64,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct FileNodeId {
    // Windows: (volume_serial_number as u64) << 64 | file_index
    // Linux/Unix: (device_id as u64) << 64 | inode
    // We combine them into a single u128 for easy storage
    pub id: u128,
}
</file>

<file path="crates/core/src/state.rs">
use crate::models::{Op, LedgerEntry};
use anyhow::Result;

pub fn reconstruct_content(ops: &[LedgerEntry]) -> String {
    let mut content = String::new();
    
    // Sort logic? We assume ops are in sequence order from get_ops
    // But Ops themselves might be concurrent in a real CRDT.
    // For Phase 0, we assume linear history from a single device (mostly).
    // If we use Loro later, it handles this.
    // For now, naive string manipulation.
    
    for entry in ops {
        match &entry.op {
            Op::Insert { pos, content: text } => {
                if *pos >= content.len() {
                    content.push_str(text);
                } else {
                    content.insert_str(*pos, text);
                }
            }
            Op::Delete { pos, len } => {
                if *pos < content.len() {
                    let end = std::cmp::min(pos + len, content.len());
                    content.drain(*pos..end);
                }
            }
        }
    }
    
    content
}

pub fn compute_diff(old: &str, new: &str) -> Vec<Op> {
    use dissimilar::Chunk;
    let chunks = dissimilar::diff(old, new);
    let mut ops = Vec::new();
    let mut pos = 0;
    
    for chunk in chunks {
        match chunk {
            Chunk::Equal(text) => {
                pos += text.len();
            }
            Chunk::Insert(text) => {
                ops.push(Op::Insert {
                    pos,
                    content: text.to_string(),
                });
                pos += text.len();
            }
            Chunk::Delete(text) => {
                ops.push(Op::Delete {
                    pos,
                    len: text.len(),
                });
                // Do not advance pos, because we deleted content so the "next" character
                // shifts left to the current pos.
            }
        }
    }
    ops
}
</file>

<file path="crates/core/src/vfs.rs">
use anyhow::Result;
use std::path::{Path, PathBuf};
use walkdir::WalkDir;
use crate::ledger::Ledger;
use crate::models::FileNodeId;
use file_id::FileId;

pub struct Vfs {
    pub root: PathBuf,
}

impl Vfs {
    pub fn new(root: impl AsRef<Path>) -> Self {
        let root = root.as_ref();
        let abs_root = std::fs::canonicalize(root).unwrap_or_else(|_| root.to_path_buf());
        Self {
            root: abs_root,
        }
    }

    pub fn get_inode(&self, rel_path: &str) -> Result<Option<FileNodeId>> {
        let full_path = self.root.join(rel_path);
        if !full_path.exists() {
            return Ok(None);
        }
        
        let file_id = file_id::get_file_id(&full_path)?;
        
        // Hash the FileId to get a stable u128 for Redb
        // This is a simplification. Ideally we should serialize FileId.
        // For Phase 0, we use a simple hash.
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};
        
        let mut hasher = DefaultHasher::new();
        file_id.hash(&mut hasher);
        let hash = hasher.finish(); 
        // FileId hash is u64. We can use it. FileNodeId wraps u128.
        
        Ok(Some(FileNodeId { id: hash as u128 }))
    }

    /// Scan the vault directory and ensure every markdown file has a DocId in the Ledger.
    pub fn scan(&self, ledger: &Ledger) -> Result<usize> {
        let mut count = 0;
        for entry in WalkDir::new(&self.root).into_iter().filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "md") {
                // Relativize path
                if let Ok(rel_path) = path.strip_prefix(&self.root) {
                    let path_str = rel_path.to_string_lossy();
                    
                    // 1. Ensure DocId exists
                    let doc_id = if let Some(id) = ledger.get_docid(&path_str)? {
                        id
                    } else {
                        let id = ledger.create_docid(&path_str)?;
                        count += 1;
                        id
                    };

                    // 2. Bind Inode (Vital for Rename detection)
                    if let Ok(Some(inode)) = self.get_inode(&path_str) {
                         // We always update the inode mapping to the latest
                         let _ = ledger.bind_inode(&inode, doc_id);
                    }
                }
            }
        }
        Ok(count)
    }
}
</file>

<file path="crates/core/src/watcher.rs">
use anyhow::Result;
use notify_debouncer_mini::{new_debouncer, notify::RecursiveMode};
use std::time::Duration;
use crate::ledger::Ledger;
use crate::vfs::Vfs;
use tracing::{info, warn, error};

pub struct Watcher {
    ledger: Ledger, // Shared? Or clone? Redb is thread-safe (Arc internal). Simple struct wrap is fine if cheap.
    vfs: Vfs,
}

impl Watcher {
    pub fn new(ledger: Ledger, vfs: Vfs) -> Self {
        Self { ledger, vfs }
    }

    pub fn watch(&self) -> Result<()> {
        let (tx, rx) = std::sync::mpsc::channel();

        // 200ms debounce
        let mut debouncer = new_debouncer(Duration::from_millis(200), tx)?;

        debouncer
            .watcher()
            .watch(&self.vfs.root, RecursiveMode::Recursive)?;

        info!("Watcher started on {:?}", self.vfs.root);

        for result in rx {
            match result {
                Ok(events) => {
                    for event in events {
                       println!("DEBUG: Event: {:?}", event);
                       let path = event.path;
                       // Convert to relative string
                       if let Ok(rel) = path.strip_prefix(&self.vfs.root) {
                           let path_str = rel.to_string_lossy().to_string();
                           if let Err(e) = self.handle_event(&path_str) {
                               error!("Error handling event for {}: {:?}", path_str, e);
                           }
                       }
                    }
                }
                Err(e) => {
                    error!("Watch error: {:?}", e);
                }
            }
        }

        Ok(())
    }

    fn handle_event(&self, path_str: &str) -> Result<()> {
        println!("DEBUG: Handling event for {}", path_str);
        if let Some(inode) = self.vfs.get_inode(path_str)? {
            println!("DEBUG: Inode found: {:?}", inode);
            // File EXISTS. 
            // Check if we know this Inode.
            if let Some(doc_id) = self.ledger.get_docid_by_inode(&inode)? {
                // Known Inode.
                // Check if Path matches.
                if let Some(known_path) = self.ledger.get_path_by_docid(doc_id)? {
                    if known_path != path_str {
                        // Inode matches, but Path differs. -> RENAME DETECTED.
                        info!("Rename detected: {} -> {}", known_path, path_str);
                        self.ledger.rename_doc(&known_path, path_str)?;
                        // Update Inode binding just in case? Inode is key, DocId is value.
                        // Inode->DocId is constant, but we might want to ensure it.
                    } else {
                        // Same path, same inode. Content update?
                        // Diff Check & Create Op.
                        info!("Content update at {}", path_str);
                        
                        let new_content = std::fs::read_to_string(&self.vfs.root.join(path_str))?;
                        let ops = self.ledger.get_ops(doc_id)?;
                        let old_content = crate::state::reconstruct_content(&ops);
                        
                        if new_content != old_content {
                            let diff_ops = crate::state::compute_diff(&old_content, &new_content);
                            if !diff_ops.is_empty() {
                                info!("Detected {} changes. Appending to Ledger.", diff_ops.len());
                                let now = chrono::Utc::now().timestamp_millis();
                                for op in diff_ops {
                                    let entry = crate::models::LedgerEntry {
                                        doc_id,
                                        op,
                                        timestamp: now,
                                    };
                                    self.ledger.append_op(&entry)?;
                                }
                            }
                        }
                    }
                }
            } else {
                // UTTERLY NEW INODE -> New File (or copied from outside).
                info!("New file detected: {}", path_str);
                let doc_id = self.ledger.create_docid(path_str)?;
                self.ledger.bind_inode(&inode, doc_id)?;
                
                // Ingest initial content
                let content = std::fs::read_to_string(&self.vfs.root.join(path_str))?;
                if !content.is_empty() {
                    let now = chrono::Utc::now().timestamp_millis();
                    let op = crate::models::Op::Insert { pos: 0, content };
                    let entry = crate::models::LedgerEntry {
                        doc_id,
                        op,
                        timestamp: now,
                    };
                    self.ledger.append_op(&entry)?;
                    info!("Ingested initial content for {}", path_str);
                }
            }
        } else {
            // File does NOT exist. DELETION?
            // Wait, if it was a rename, we might see Delete(Old) then Create(New).
            // But we process Create(New) above and handle the rename.
            // If it is a pure delete, Inode is gone.
            // We check if Path was known.
            if let Some(_doc_id) = self.ledger.get_docid(path_str)? {
                 // Known path is gone.
                 // Verify if it moved? 
                 // If we processed the "Rename/Move" event first, `get_docid(path_str)` might already be None (if we updated ledger).
                 // But if we see Delete first...
                 // We can't know if it moved unless we see the destination.
                 // So we conservatively mark it as deleted or just wait.
                 // For Phase 0, let's log it.
                 warn!("File gone: {}", path_str);
            }
        }

        Ok(())
    }
}
</file>

<file path="dump_hello.txt">
warning: unused import: `file_id::FileId`
 --> crates\core\src\vfs.rs:6:5
  |
6 | use file_id::FileId;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `anyhow::Result`
 --> crates\core\src\state.rs:2:5
  |
2 | use anyhow::Result;
  |     ^^^^^^^^^^^^^^

warning: `deve_core` (lib) generated 2 warnings (run `cargo fix --lib -p deve_core` to apply 2 suggestions)
warning: unused variable: `path`
  --> apps\cli\src\main.rs:43:31
   |
43 | ... { path }) ...
   |       ^^^^ help: try ignoring the field: `path: _`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: `deve_cli` (bin "deve_cli") generated 1 warning (run `cargo fix --bin "deve_cli" -p deve_cli` to apply 1 suggestion)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target\debug\deve_cli.exe dump --path hello.md`
DocId: 89be5b7d-fa27-4298-832f-c640611e60dd
Found 0 ops:

Reconstructed Content:
---

---
</file>

<file path="dump.txt">
warning: unused import: `file_id::FileId`
 --> crates\core\src\vfs.rs:6:5
  |
6 | use file_id::FileId;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `anyhow::Result`
 --> crates\core\src\state.rs:2:5
  |
2 | use anyhow::Result;
  |     ^^^^^^^^^^^^^^

warning: `deve_core` (lib) generated 2 warnings (run `cargo fix --lib -p deve_core` to apply 2 suggestions)
warning: unused variable: `path`
  --> apps\cli\src\main.rs:43:31
   |
43 | ... { path }) ...
   |       ^^^^ help: try ignoring the field: `path: _`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: `deve_cli` (bin "deve_cli") generated 1 warning (run `cargo fix --bin "deve_cli" -p deve_cli` to apply 1 suggestion)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.27s
     Running `target\debug\deve_cli.exe dump --path test_diff.md`
DocId: 63d80ad0-0586-4608-97c6-d1696fe37f23
Found 0 ops:

Reconstructed Content:
---

---
</file>

<file path="scan.txt">
warning: unused import: `file_id::FileId`
 --> crates\core\src\vfs.rs:6:5
  |
6 | use file_id::FileId;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `anyhow::Result`
 --> crates\core\src\state.rs:2:5
  |
2 | use anyhow::Result;
  |     ^^^^^^^^^^^^^^

warning: `deve_core` (lib) generated 2 warnings (run `cargo fix --lib -p deve_core` to apply 2 suggestions)
warning: unused variable: `path`
  --> apps\cli\src\main.rs:43:31
   |
43 | ... { path }) ...
   |       ^^^^ help: try ignoring the field: `path: _`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: `deve_cli` (bin "deve_cli") generated 1 warning (run `cargo fix --bin "deve_cli" -p deve_cli` to apply 1 suggestion)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target\debug\deve_cli.exe scan`
Scanning vault at "vault"...
Scanned. Registered 1 new documents.
</file>

<file path="verify_debug.txt">
Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
warning: unused import: `file_id::FileId`
 --> crates\core\src\vfs.rs:6:5
  |
6 | use file_id::FileId;
  |     ^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `anyhow::Result`
 --> crates\core\src\state.rs:2:5
  |
2 | use anyhow::Result;
  |     ^^^^^^^^^^^^^^

warning: `deve_core` (lib) generated 2 warnings (run `cargo fix --lib -p deve_core` to apply 2 suggestions)
   Compiling deve_cli v0.0.1 (E:\gitclone\Deve-Note\apps\cli)
warning: unused variable: `path`
  --> apps\cli\src\main.rs:43:31
   |
43 |         Some(Commands::Init { path }) => {
   |                               ^^^^ help: try ignoring the field: `path: _`
   |
   = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: `deve_cli` (bin "deve_cli") generated 1 warning (run `cargo fix --bin "deve_cli" -p deve_cli` to apply 1 suggestion)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 2.45s
     Running `target\debug\deve_cli.exe watch`
Starting watcher on "vault"... Press Ctrl+C to stop.
[2m2026-01-07T06:44:20.773673Z[0m [32m INFO[0m [2mdeve_core::watcher[0m[2m:[0m Watcher started on "vault"
DEBUG: Event: DebouncedEvent { path: "E:\\gitclone\\Deve-Note\\vault\\hello.md", kind: Any }
</file>

<file path="verify_final.txt">
Compiling deve_core v0.0.1 (E:\gitclone\Deve-Note\crates\core)
</file>

<file path=".gitignore">
# Rust
/target
/debug
/release
**/*.rs.bk
Cargo.lock

# IDEs
.vscode/
.idea/
*.iml

# OS
Thumbs.db
.DS_Store

# Project Specific
deve.db
vault/
*.log
</file>

<file path="deve-note plan.md">
# ğŸ“‘ Deve-Note plan - ç³»ç»Ÿæ¶æ„

**ç‰ˆæœ¬**ï¼š0.0.1
**çŠ¶æ€**ï¼šåç«¯é€»è¾‘é—­ç¯ + å‰ç«¯äº¤äº’å®šä¹‰å®Œæ•´ + æ•°æ®/å®‰å…¨å¼ºåŒ–è½åœ°ã€‚
**æ ¸å¿ƒç†å¿µ**ï¼šè´¦æœ¬ä¸ºçœŸæº + ID åŒ– VFS + å·¥ä¸šçº§å†…æ ¸ (Industrial Kernel) + æ²‰æµ¸å¼é©¾é©¶èˆ± (Immersive Cockpit)ã€‚

**é¡¹ç›®å®šä½**ï¼šä¸ªäººéƒ¨ç½²åœ¨æœåŠ¡å™¨ä¸Šï¼Œä»…ä¾›è‡ªå·±ä½¿ç”¨çš„å¼€æºä¸ªäºº Wiki Markdown ç¬”è®°é¡¹ç›®ï¼ˆæ”¯æŒ LaTeX æ•°å­¦å…¬å¼ï¼‰ã€‚

## æœ¯è¯­ä¸è§„èŒƒæ€§ç”¨è¯­ (Terminology)

ä¸ºé¿å…â€œæƒ³æ³•æ­£ç¡®ä½†å®ç°å«ç³Šâ€ï¼Œæœ¬ç™½çš®ä¹¦å¯¹å…³é”®æœ¯è¯­ç»™å‡º**å®šä¹‰**ï¼Œå¹¶ä½¿ç”¨ä»¥ä¸‹è§„èŒƒæ€§ç”¨è¯­ï¼š

* **MUST / å¿…é¡»**ï¼šä¸å¯è¿åï¼›è¿åå³è§†ä¸ºè®¾è®¡ä¸æˆç«‹æˆ–å®ç°é”™è¯¯ã€‚
* **SHOULD / åº”**ï¼šå¼ºçƒˆå»ºè®®ï¼›é™¤éæœ‰æ˜ç¡®ç†ç”±ä¸æ›¿ä»£æ–¹æ¡ˆï¼Œå¦åˆ™ä¸åº”åç¦»ã€‚
* **MAY / å¯é€‰**ï¼šå¯æŒ‰é˜¶æ®µæˆ–æ’ä»¶åŒ–å®ç°ï¼Œä¸è¿›å…¥æ ¸å¿ƒå¿…é€‰è·¯å¾„ã€‚

**è¡¨è¾¾çº¦å®šï¼ˆè¿½æ±‚ç²¾ç¡®ç®€ç»ƒï¼‰**ï¼š

* æ¯æ¡è¦æ±‚ SHOULD å¯éªŒè¯ï¼ˆèƒ½å†™æµ‹è¯•/èƒ½è§‚æµ‹/èƒ½å¤ç°ï¼‰ï¼Œé¿å…â€œæ›´å¥½/æ›´å¼º/æ›´ä¼˜é›…â€è¿™ç±»ä¸å¯åˆ¤å®šè¡¨è¿°ã€‚
* ä»»ä½•å½±å“ä¸€è‡´æ€§ä¸å®‰å…¨æ€§çš„äº‹å® MUST ä½äº Ledgerï¼Œæˆ– MUST å¯ç”± Ledger å”¯ä¸€æ¨å¯¼ï¼›Vault/Markdown ä»…æ‰¿è½½å¯è¯»æŠ•å½±ã€‚
* éœ€è¦æ˜ç¡®è¾¹ç•Œæ—¶ï¼Œä½¿ç”¨â€œ**éç›®æ ‡**â€ç›´æ¥æ’é™¤ã€‚

**æ ¸å¿ƒæœ¯è¯­å®šä¹‰**ï¼š

* **Ledgerï¼ˆè´¦æœ¬ï¼‰**ï¼šappend-only çš„ CRDT æ“ä½œæ—¥å¿—ï¼ˆOps Logï¼‰ä¸å…¶æ´¾ç”Ÿçš„å¿«ç…§ï¼ˆSnapshotï¼‰é›†åˆï¼›Ledger æ˜¯ç³»ç»Ÿå”¯ä¸€çœŸæºã€‚
* **Snapshotï¼ˆå¿«ç…§ï¼‰**ï¼šå¯¹æŸä¸€æ—¶ç‚¹ Ledger çŠ¶æ€çš„å‹ç¼©è¡¨ç¤ºï¼Œç”¨äºå¿«é€ŸåŠ è½½ä¸è¡¥å¿é•¿æ—¥å¿—å›æ”¾ã€‚
* **Projectionï¼ˆæŠ•å½±ï¼‰**ï¼šä» Ledger æ´¾ç”Ÿçš„å¯è¯»/å¯ç¼–è¾‘è¡¨ç°å½¢å¼ï¼ˆä¾‹å¦‚ Markdown æ–‡ä»¶ï¼‰ï¼›æŠ•å½±ä¸æ˜¯æƒå¨æºã€‚
* **Vaultï¼ˆæŠ•å½±ä»“ï¼‰**ï¼šä¿å­˜æŠ•å½±æ–‡ä»¶çš„ç›®å½•ï¼ˆæœ¬æ–¹æ¡ˆä¸º `/data/vault`ï¼‰ã€‚
* **DocId**ï¼šæ–‡æ¡£/èµ„äº§çš„ç¨³å®šä¸»é”®ï¼ˆUUIDï¼‰ï¼Œä¸éšé‡å‘½å/ç§»åŠ¨æ”¹å˜ã€‚
* **Path Mappingï¼ˆè·¯å¾„æ˜ å°„ï¼‰**ï¼šDocId ä¸å¯è§è·¯å¾„ä¹‹é—´çš„å¯å˜æ˜ å°„ï¼›é‡å‘½å/ç§»åŠ¨ MUST åªä¿®æ”¹æ˜ å°„ï¼Œä¸ä¿®æ”¹ DocIdã€‚
* **Capabilityï¼ˆèƒ½åŠ›æ¸…å•ï¼‰**ï¼šæ’ä»¶/è„šæœ¬å£°æ˜çš„æœ€å°æƒé™é›†åˆï¼›Host MUST åœ¨è¿è¡Œæ—¶å¼ºåˆ¶æ ¡éªŒã€‚
* **Host Functionsï¼ˆå®¿ä¸»å‡½æ•°ï¼‰**ï¼šæ ¸å¿ƒæš´éœ²ç»™æ’ä»¶çš„å—æ§ APIï¼ˆä¾‹å¦‚æŒ‰ DocId è¯»å†™ã€æ³¨å†Œå‘½ä»¤ã€ç½‘ç»œè¯·æ±‚ç­‰ï¼‰ï¼Œæ‰€æœ‰è°ƒç”¨ MUST å¯å®¡è®¡ã€å¯é™æƒã€‚
* **Assetï¼ˆèµ„äº§ï¼‰**ï¼šå›¾ç‰‡/é™„ä»¶ç­‰äºŒè¿›åˆ¶å¯¹è±¡ï¼Œæ‹¥æœ‰ç‹¬ç«‹ DocIdï¼›è¿è¡Œæ—¶ä»¥ `asset://<uuid>` å¼•ç”¨ï¼Œå¯¼å‡ºæ—¶ MUST è½ä¸ºæ ‡å‡† Markdown å¼•ç”¨ã€‚
* **Reconciliationï¼ˆå’Œè§£ï¼‰**ï¼šæ£€æµ‹å¹¶åˆå¹¶å¤–éƒ¨ä¿®æ”¹ï¼ˆä¾‹å¦‚ VS Code ç›´æ¥æ”¹ Vault æ–‡ä»¶ï¼‰åˆ° Ledger çš„è¿‡ç¨‹ã€‚
* **Job Queueï¼ˆä½œä¸šé˜Ÿåˆ—ï¼‰**ï¼šç”¨äºæ‰§è¡Œé•¿ä»»åŠ¡/æ’ä»¶ä»»åŠ¡/AI è°ƒç”¨çš„å—æ§é˜Ÿåˆ—ï¼Œæä¾›è¶…æ—¶ã€å–æ¶ˆä¸å¹¶å‘ä¸Šé™ã€‚

## æ ¸å¿ƒè¾¹ç•Œï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰

ä»¥ä¸‹è¾¹ç•Œç”¨äºé˜²æ­¢æ ¸å¿ƒè†¨èƒ€ï¼›ä¸ä»»ä½•å…¶å®ƒç« èŠ‚å†²çªæ—¶ï¼Œä»¥æœ¬èŠ‚ä¸ºå‡†ã€‚

**Core MUSTï¼ˆæ ¸å¿ƒå¿…é¡»ï¼‰**ï¼š

* åªæä¾›â€œä¾§è¾¹æ å¯¼èˆª + å‘½ä»¤ç³»ç»Ÿ + Markdown æ’°å†™ä½“éªŒï¼ˆå« TeX å…¬å¼æ¸²æŸ“ï¼‰â€çš„æœ€å°é—­ç¯ã€‚
* ç»´æŠ¤ Ledger/Vault çš„ä¸€è‡´æ€§é—­ç¯ï¼šå†™å…¥ã€åŒæ­¥ã€å’Œè§£ã€å†²çªå¤„ç†ã€å¯æ¢å¤æ€§ä¸å¯è§‚æµ‹æ€§ã€‚
* æä¾›ç¨³å®šçš„ Host Functionsã€äº‹ä»¶æ€»çº¿ã€ä½œä¸šé˜Ÿåˆ—ä¸ Capability æ ¡éªŒï¼Œç”¨äºæ‰¿è½½æ’ä»¶æ‰©å±•ã€‚

**Core MUST NOTï¼ˆæ ¸å¿ƒç¦æ­¢ï¼‰**ï¼š

* ä¸å†…ç½®ä»»ä½•é‡èƒ½åŠ›ä¸ºé»˜è®¤å¿…é€‰è·¯å¾„ï¼šAIã€å…¨æ–‡ç´¢å¼•ã€è®¡ç®—/æ‰§è¡Œå‹ä»£ç å—ã€æ‰¹é‡å¯¼å…¥å¯¼å‡ºç®¡çº¿ã€å›¾åƒå¤„ç†ã€å¤æ‚æ¸²æŸ“/æ’ç‰ˆç­‰ã€‚
* ä¸è®©ä»»ä½•é‡ä»»åŠ¡é˜»å¡äº¤äº’ï¼šæ ¸å¿ƒ UI è·¯å¾„å¿…é¡»æ’è½»ï¼›é‡ä»»åŠ¡å¿…é¡»èµ°ä½œä¸šé˜Ÿåˆ—å¹¶å¯å–æ¶ˆ/å¯é™çº§ã€‚
* ä¸å¼•å…¥ç§æœ‰æ ¼å¼æ±¡æŸ“å¯¼å‡ºï¼šå¯¹ç”¨æˆ·å¯è§çš„æ–‡æœ¬æŠ•å½±å¿…é¡»ä¿æŒæ ‡å‡† Markdown è¯­ä¹‰ã€‚
* **Ignored Files Strategy (å¿½ç•¥ç­–ç•¥)**ï¼šå¯¹äº Vault ä¸­æ— æ³•è§£ææˆ–è¿‡å¤§çš„é Markdown/é Asset æ–‡ä»¶ï¼ˆå¦‚ç¼–è¯‘äº§ç‰©ã€ç³»ç»Ÿä¸´æ—¶æ–‡ä»¶ï¼‰ï¼Œæ ¸å¿ƒ **MUST** ä¾æ® `.deveignore` æˆ–å†…ç½®è§„åˆ™ç›´æ¥å¿½ç•¥ï¼Œ**MUST NOT** å°è¯•å°†å…¶æ‘„å…¥ Ledgerï¼Œé¿å…æ ¸å¿ƒè†¨èƒ€æˆ–é˜»å¡ã€‚

**Plugin MAYï¼ˆæ’ä»¶å¯é€‰ï¼‰**ï¼š

* å®ç°å¹¶æŒ‰éœ€å¯ç”¨é‡èƒ½åŠ›ï¼ˆAIã€ç´¢å¼•ã€å¯æ‰§è¡Œ fenced blocksã€å›¾åƒ/è¡¨æ ¼/å›¾å½¢ã€æ‰¹å¤„ç†å·¥å…·ç­‰ï¼‰ï¼Œå¹¶é€šè¿‡ Capabilityã€èµ„æºé…é¢ä¸é˜Ÿåˆ—ä¸Šé™è¿›è¡Œéš”ç¦»ã€‚
* æ‰©å±• UIï¼ˆé¢æ¿/å‘½ä»¤/é¢„è§ˆå™¨/ä¾§æ å°ç»„ä»¶ï¼‰ä¸æ•°æ®èƒ½åŠ›ï¼ˆèµ„äº§å¤„ç†ã€å¤–éƒ¨é›†æˆï¼‰ï¼Œä½†ä¸å¾—ç ´å Ledger çœŸæºä¸å¯¼å‡ºçº¦æŸã€‚


---

## Phase 0: æ ¸å¿ƒéªŒè¯åŸå‹ (Headless Core Verification) - [æ–°å¢å¿…é€‰é¡¹]

åœ¨æ„å»ºä»»ä½• UI ä¹‹å‰ï¼Œ**å¿…é¡»**å…ˆè¡Œæ„å»ºå¹¶é€šè¿‡éªŒè¯çš„çº¯å‘½ä»¤è¡ŒåŸå‹ï¼ˆHeadless CLIï¼‰ã€‚

*   **ç›®æ ‡**ï¼šéªŒè¯ `Reconciliation`ï¼ˆå’Œè§£ï¼‰çš„é²æ£’æ€§ï¼Œç¡®ä¿ Ledger ä¸å¤§é‡ä¸å¯é å¤–éƒ¨å†™å…¥å¹¶å­˜æ—¶æ•°æ®ä¸ä¸¢å¤±ã€‚
*   **åŠŸèƒ½æ¸…å•**ï¼š
    1.  `init`: åˆå§‹åŒ– Ledger å’Œ Vaultã€‚
    2.  `watch`: å¯åŠ¨æ–‡ä»¶ç›‘å¬ï¼Œèƒ½å¤Ÿæ­£ç¡®å¤„ç† `vim`/`vscode` çš„ä¿å­˜è¡Œä¸ºï¼ˆå«é‡å‘½å/åŸå­å†™å…¥ï¼‰ã€‚
    3.  `append`: é€šè¿‡ API è¿½åŠ  Opsï¼ŒéªŒè¯ Vault èƒ½å¦æ­£ç¡®æ›´æ–°ã€‚
*   **éªŒæ”¶æ ‡å‡†**ï¼š
    *   **åŒå‘åŒæ­¥é—­ç¯**ï¼š`VS Code ä¿®æ”¹ -> Watcher -> Ledger -> Vault æ›´æ–°` å¿…é¡»ç¨³å®šï¼Œæ— æ­»å¾ªç¯ã€‚
    *   **é‡å‘½åæµ‹è¯•**ï¼šåœ¨æ­¤é˜¶æ®µå¿…é¡»è§£å†³â€œæ–‡ä»¶é‡å‘½åè¢«è¯†åˆ«ä¸ºåˆ é™¤+æ–°å»ºâ€å¯¼è‡´çš„ DocId ä¸¢å¤±é—®é¢˜ï¼ˆå®ç° Inode/FileID è¿½è¸ªï¼‰ã€‚

---

## ç¬¬ä¸€ç« ï¼šç•Œé¢è®¾è®¡å“²å­¦ (UI Design Philosophy) - [æ–°å¢æ ¸å¿ƒ]

### 1. The "Cockpit" Concept (é©¾é©¶èˆ±æ¦‚å¿µ)

* **ä¿¡æ¯åˆ†å±‚**ï¼š
	* **L1 (Focus)**ï¼šç¼–è¾‘åŒºæ˜¯ç»å¯¹ä¸­å¿ƒï¼Œæ— å¹²æ‰°ã€‚
	* **L2 (Context)**ï¼šä¾§è¾¹æ ï¼ˆå¤§çº²ã€æ–‡ä»¶æ ‘ï¼‰æä¾›å¯¼èˆªã€‚
	* **L3 (Meta)**ï¼šåº•éƒ¨çŠ¶æ€æ æ˜¾ç¤ºâ€œå’Œè§£çŠ¶æ€â€ï¼ˆSync/Watcherï¼‰ã€Git åˆ†æ”¯ã€å­—æ•°ç»Ÿè®¡ã€‚
	* **L4 (Floating)**ï¼š`Cmd+K` å‘½ä»¤é¢æ¿å’Œæ‚¬æµ®å·¥å…·æ ï¼ŒæŒ‰éœ€å‡ºç°ã€‚

* **é”®ç›˜ä¼˜å…ˆ (Keyboard First)**ï¼š
	* æ‰€æœ‰ UI æ“ä½œï¼ˆåˆ‡æ¢ä¾§è¾¹æ ã€åˆ†å±ã€æœç´¢ã€è·³è½¬ï¼‰å¿…é¡»æœ‰å¿«æ·é”®ã€‚
	* æ¨¡ä»¿ Vim/VS Code çš„æ“ä½œé€»è¾‘ï¼Œå‡å°‘é¼ æ ‡ç§»åŠ¨ã€‚



### 2. Reactive Projection (å“åº”å¼æŠ•å½±)

* **å³æ—¶åé¦ˆ**ï¼šå½“åç«¯ Watcher æ£€æµ‹åˆ°ç£ç›˜ä¸Šçš„æ–‡ä»¶è¢« VS Code ä¿®æ”¹æ—¶ï¼Œå‰ç«¯ç¼–è¾‘å™¨ä¸åº”â€œåˆ·æ–°é¡µé¢â€ï¼Œè€Œåº”é€šè¿‡ **Loro çš„ Diff è¡¥ä¸** å¹³æ»‘åœ°æ›´æ–°å†…å®¹ï¼Œå¹¶å¼¹å‡ºä¸€ä¸ªéä¾µå…¥å¼çš„ Toast æç¤ºï¼šâ€œå·²åˆå¹¶å¤–éƒ¨ä¿®æ”¹â€ã€‚
* **ä¹è§‚ UI (Optimistic UI)**ï¼šç”¨æˆ·è¾“å…¥ç«‹å³ä¸Šå±ï¼ŒWebSocket åŒæ­¥åœ¨åå°æ‚„æ‚„è¿›è¡Œã€‚å¦‚æœç½‘ç»œå¤±è´¥ï¼ŒçŠ¶æ€æ å›¾æ ‡å˜çº¢ï¼Œä½†ç¼–è¾‘ä¸ä¸­æ–­ã€‚

### 3. Mathematical Aesthetics (æ•°å­¦ç¾å­¦)

* **æ’ç‰ˆ**ï¼šé»˜è®¤é›†æˆ **KaTeX** (å¿«é€Ÿ) æˆ– **MathJax 3** (ç²¾ç¡®)ï¼Œæ”¯æŒå¤æ‚çš„æ•°å­¦å…¬å¼æ¸²æŸ“ã€‚
* **å­—ä½“**ï¼šé¢„è®¾é€‚åˆä»£ç å’Œæ•°å­¦å…¬å¼çš„ç­‰å®½å­—ä½“ (å¦‚ JetBrains Mono, Fira Code) å’Œè¡¬çº¿å­—ä½“ (å¦‚ Merriweather)ã€‚

### 4. Ledger/VFS/Security Principles (çœŸæºä¸å®‰å…¨)

* **Ledger is Truthï¼ˆçœŸæºä¸å˜é‡ï¼‰**ï¼š
	* æƒå¨çŠ¶æ€ MUST ä»…ç”± Ledger è¡¨è¾¾ï¼ˆOps Log + Snapshotï¼‰ã€‚
	* Vault/Markdown MUST å¯ç”± Ledger é‡å»ºï¼›ä¸å¾—å­˜åœ¨â€œä»…åœ¨ Vault æ‰å­˜åœ¨ã€ä¸”æ— æ³•ç”± Ledger æ¨å¯¼â€çš„ç”¨æˆ·å¯è§äº‹å®ã€‚

* **ID-Based VFSï¼ˆæ ‡è¯†ä¸å˜é‡ï¼‰**ï¼š
	* æ‰€æœ‰å®ä½“ï¼ˆæ–‡æ¡£/èµ„äº§ï¼‰MUST ä»¥ `DocId (UUID)` ä¸ºä¸»é”®ã€‚
	* è·¯å¾„ MUST ä»…ä½œä¸ºæ˜¾ç¤ºå±æ€§ï¼›é‡å‘½å/ç§»åŠ¨ MUST åªä¿®æ”¹ Path Mappingã€‚
	* å†…éƒ¨é“¾æ¥ MUST è§£æä¸º DocIdï¼›å¯¼å‡ºæ—¶ MAY è½¬ä¸ºç›¸å¯¹è·¯å¾„é“¾æ¥ï¼ˆä¿æŒæ ‡å‡† Markdownï¼‰ã€‚

* **Capability-Based Securityï¼ˆæƒé™ä¸å˜é‡ï¼‰**ï¼š
	* è„šæœ¬/æ’ä»¶ MUST å£°æ˜èƒ½åŠ›æ¸…å•ï¼ˆç½‘ç»œåŸŸåã€FS è·¯å¾„ã€env å˜é‡ç™½åå•ï¼‰ã€‚
	* Host Functions MUST æ‰§è¡Œæœ€å°æƒé™æ ¡éªŒä¸å®¡è®¡ï¼ˆdefault denyï¼‰ã€‚

### 5. ä½“éªŒå–èˆä¸å…¼å®¹æ€§ (Inspiration & Compatibility)

* **é£æ ¼å‚è€ƒ**ï¼šUI è§†è§‰ä¸ç‰ˆå¼å€Ÿé‰´è¯­é›€çš„æ¸…çˆ½é˜…è¯»æ„Ÿï¼Œä½†ä¿æŒå¼€æºå¯è‡ªå®šä¹‰ä¸»é¢˜ã€‚
* **æ ‡å‡† Markdown å¯¼å‡º**ï¼šå¯¼å‡º/æŠ•å½±åšæŒé€šç”¨ GFM/Frontmatterï¼Œä¸æ·»åŠ ç§æœ‰æ ‡è®°æˆ–è¯­é›€å¼ç‰¹æœ‰æ ¼å¼ï¼›å¯Œæ–‡æœ¬å…ƒæ•°æ®ä»…å­˜äº Ledgerã€‚
* **æ•ˆç‡å–å‘**ï¼šæ’ä»¶ä¸äº¤äº’å€¾å‘ SilverBullet çš„è½»é‡/å®ç”¨ï¼Œé¿å…è‡ƒè‚¿ï¼›é»˜è®¤è£…è½½æœ€å°å¯ç”¨é›†ã€‚
* **å¯¼èˆªä½“éªŒ**ï¼šä¾§è¾¹æ ç»“æ„å‚è€ƒ VitePressï¼ˆåˆ†ç»„/å±‚çº§æ¸…æ™°ï¼‰ï¼Œå‘½ä»¤/å¿«æ·é”®å‘¼å‡ºæ–‡ä»¶åˆ—è¡¨å‚è€ƒ SilverBullet å¼¹å‡ºå¼æœç´¢ã€‚

---

## ç¬¬äºŒç« ï¼šUI æ¶æ„ä¸ç»„ä»¶ç³»ç»Ÿ (UI Architecture) - [æ–°å¢æ ¸å¿ƒ]

å‰ç«¯é‡‡ç”¨ **Leptos (Signals)** + **Tailwind CSS**ï¼Œæ„å»ºä¸€å¥—é«˜æ€§èƒ½ç»„ä»¶åº“ã€‚

### 1. å¸ƒå±€ç³»ç»Ÿ (The Layout Engine)

é‡‡ç”¨ **"Resizable Slot" (å¯ç¼©æ”¾æ’æ§½)** å¸ƒå±€ï¼š

* **Left Slot**: æ–‡ä»¶æ ‘ï¼ˆæ ¸å¿ƒï¼‰/ åŒå‘é“¾æ¥å›¾è°± (Mini Graph, æ’ä»¶å¯é€‰)ã€‚
* **Main Slot**: å¤šæ ‡ç­¾é¡µ (Tabs) ç¼–è¾‘å™¨ / åˆ†å± (Split View)ã€‚
* **Right Slot**: å¤§çº² (TOC) / å±æ€§é¢æ¿ (Metadata) / æ’ä»¶é¢æ¿ã€‚
* **Bottom Slot**: æ—¥å¿—è¾“å‡ºï¼ˆæ ¸å¿ƒï¼‰/ ç»ˆç«¯é¢æ¿ (Terminal, æ’ä»¶å¯é€‰)ã€‚
* **ç‰¹æ€§**ï¼šæ‰€æœ‰é¢æ¿çŠ¶æ€ï¼ˆå®½åº¦ã€æŠ˜å ï¼‰æŒä¹…åŒ–å­˜å‚¨åœ¨ Redb çš„ `ui_state` è¡¨ä¸­ï¼Œé‡å¯åå®Œå…¨æ¢å¤ï¼›ä¾§è¾¹æ åˆ†ç»„/å±‚çº§å¯é…ç½®ï¼Œé£æ ¼é è¿‘ VitePress çš„å¯¼èˆªç»“æ„ã€‚

### 2. ç¼–è¾‘å™¨å†…æ ¸ (The Editor Kernel)

ä¸ä»…ä»…æ˜¯ä¸€ä¸ª `<textarea>`ï¼Œè€Œæ˜¯ä¸€ä¸ªåˆ†å±‚æ¸²æŸ“å™¨ï¼š

* **Layer 1 (Input)**: `ContentEditable` æˆ– CodeMirror 6ï¼Œè´Ÿè´£æ•è·è¾“å…¥ã€‚
* **Layer 2 (State)**: ç»‘å®š Loro CRDT çŠ¶æ€ï¼Œå¤„ç†å¹¶å‘å†²çªã€‚
* **Layer 3 (Render)**ï¼š
	* **Block Modeï¼ˆæ’ä»¶å¯é€‰ï¼‰**ï¼šç±»ä¼¼ Notionï¼Œæ”¯æŒæ‹–æ‹½å—ã€‚
	* **Source Mode**ï¼šçº¯ Markdown æºç æ¨¡å¼ï¼ˆé…åˆ Monaco/CodeMirror é«˜äº®ï¼‰ã€‚
	* **Live Preview**ï¼šç±»ä¼¼ Obsidian/Milkdownï¼Œæºç å³æ‰€è§ã€‚

* **æŠ€æœ¯é€‰å‹ï¼ˆè½»/é‡åŒæ¨¡å¼ï¼‰**ï¼š
	* **é»˜è®¤ï¼ˆè½»æ ¸å¿ƒï¼‰**ï¼šä»¥ CodeMirror 6 çš„ Source Mode ä½œä¸ºä¸»ç¼–è¾‘ä½“éªŒï¼Œç¡®ä¿æ€§èƒ½ã€å…¼å®¹ä¸å¯¼å‡ºç¨³å®šã€‚
	* **å¯é€‰ï¼ˆé‡æ‰©å±•ï¼‰**ï¼šLive Preview / å¯Œäº¤äº’ç¼–è¾‘å™¨ä½œä¸ºå¯é€‰æ¨¡å—ï¼ˆfeature/æ’ä»¶ï¼‰å¯ç”¨ï¼Œæ¨è **Milkdown (åŸºäº Prosemirror)**ï¼Œæ’ä»¶ç”Ÿæ€ä¸°å¯Œã€‚

**Markdown åŸºçº¿èƒ½åŠ›ï¼ˆæ ¸å¿ƒï¼‰**ï¼šæ ‡é¢˜/æ®µè½/ç²—æ–œä½“/åˆ é™¤çº¿ã€æ— åº/æœ‰åº/ä»»åŠ¡åˆ—è¡¨ã€å¼•ç”¨ã€ä»£ç å—ï¼ˆè¯­è¨€é«˜äº®ï¼‰ã€è¡¨æ ¼ã€åˆ†éš”çº¿ã€é“¾æ¥/å›¾ç‰‡ã€è„šæ³¨ã€è¡Œå†…/å—çº§æ•°å­¦ï¼›å¿«æ·é”®ä¸å‘½ä»¤é¢æ¿è¦†ç›–å¸¸ç”¨æ ¼å¼ï¼›ç²˜è´´/æ‹–æ‹½å›¾ç‰‡è‡ªåŠ¨å…¥åº“å¹¶ç”Ÿæˆ DocId å¼•ç”¨ï¼›æ’¤é”€/é‡åšã€‚

**å¯é€‰å¢å¼ºï¼ˆæ’ä»¶/featureï¼‰**ï¼šå—æ‹–æ‹½/ä¸Šç§»ä¸‹ç§»ã€å¤æ‚å¯è§†åŒ–ï¼ˆå›¾è°±/æ—¶å…‰è½´ï¼‰ã€PDF/æ‰¹å¤„ç†å¯¼å‡ºã€è®¡ç®—/æ‰§è¡Œå‹èƒ½åŠ›ç­‰ï¼›é»˜è®¤ä¸è¿›å…¥æ ¸å¿ƒå¿…é€‰è·¯å¾„ã€‚

**æ•°å­¦ä½“éªŒç»†èŠ‚**ï¼šæ”¯æŒ `$...$` è¡Œå†…ä¸ `$$...$$` å—çº§æ¨¡å¼ï¼›è¾“å…¥ `$$` è‡ªåŠ¨åˆ‡å—ï¼›æ¸²æŸ“ KaTeX ä¼˜å…ˆã€å¯åˆ‡ MathJaxï¼›å…¬å¼é”™è¯¯é«˜äº®ä¸ fallback æ–‡æœ¬ï¼›å…¬å¼å—æ”¯æŒä¸€é”®å¤åˆ¶ä¸º LaTeX/å¯¼å‡º SVG/PNGï¼›ç¦»çº¿æ‰“åŒ… KaTeX èµ„æºï¼›å¤§æ–‡æ¡£ä¸­æŒ‰éœ€æ¸²æŸ“ï¼ˆè™šæ‹ŸåŒ–ï¼‰ã€‚

**LaTeX æ¸²æŸ“çº¦å®šï¼ˆæ ‡å‡† Markdownï¼‰**ï¼š

* `$...$` ä½œä¸ºè¡Œå†…å…¬å¼ç›´æ¥æ¸²æŸ“ã€‚
* `$$...$$` ä½œä¸ºè¡Œé—´å…¬å¼ç›´æ¥æ¸²æŸ“ã€‚
* **ç¦æ­¢è£¸ `$` å­—ç¬¦**ï¼šåœ¨æ™®é€šæ–‡æœ¬ä¸­ `$` MUST ä»¥ `\$` å½¢å¼å‡ºç°ï¼›ä»…å½“ `$` ç”¨ä½œå…¬å¼å®šç•Œç¬¦ï¼ˆ`$...$` / `$$...$$`ï¼‰æ—¶å…è®¸è£¸å†™ã€‚
* **æ ¡éªŒä¸ä¿®å¤**ï¼šç¼–è¾‘å™¨ SHOULD æä¾› lint æç¤ºæˆ–ä¸€é”®ä¿®å¤ï¼Œå°†éå…¬å¼è¯­å¢ƒçš„ `$` è‡ªåŠ¨æ›¿æ¢ä¸º `\$`ã€‚
* å¯¼å‡º/æŠ•å½±ä»ä¿æŒåŸå§‹ Markdown è¯­æ³•ï¼ˆä¸æ’å…¥ç§æœ‰æ ‡è®°ï¼‰ã€‚

**æ€§èƒ½ä¼˜å…ˆåŸåˆ™**ï¼šä»»ä½•â€œé‡èƒ½åŠ›â€ï¼ˆLive Previewã€å›¾è°±ã€AIã€PDFï¼‰ä¸å¾—æˆä¸ºæ ¸å¿ƒå¿…é€‰ä¾èµ–ï¼›æ ¸å¿ƒè·¯å¾„å¿…é¡»åœ¨ä½é…æœºå™¨ä¸å¤§æ–‡æ¡£ä¸‹ä¿æŒå¯ç”¨ã€‚



### 3. å¯è§†åŒ–ç³»ç»Ÿ (Visualization System)

æœ¬å°èŠ‚æ•´ä½“å±äº **Plugin MAY**ï¼ˆé»˜è®¤å…³é—­ï¼‰ï¼›æ ¸å¿ƒåªæä¾› UI æ’æ§½ã€å‘½ä»¤æ³¨å†Œä¸èƒ½åŠ›/èµ„æºéš”ç¦»ã€‚

* **Global Graph (å…¨åŸŸå›¾è°±ï¼Œæ’ä»¶å¯é€‰ï¼Œé»˜è®¤å…³é—­)**ï¼š
	* ä½¿ç”¨ **Rust -> Wasm** ç¼–è¯‘çš„åŠ›å¯¼å‘å›¾å¼•æ“ (Force-directed Graph)ï¼Œæ”¯æŒ 10,000+ èŠ‚ç‚¹æµç•…æ¸²æŸ“ï¼ˆCanvas/WebGLï¼‰ã€‚
	* æ”¯æŒæŒ‰ Tagã€æ–‡ä»¶å¤¹é¢œè‰²èšç±»ã€‚

* **Time Travel Slider (æ—¶å…‰è½´ï¼Œæ’ä»¶å¯é€‰ï¼Œé»˜è®¤å…³é—­)**ï¼š
	* UI åº•éƒ¨çš„ä¸€æ¡äº¤äº’å¼çƒ­åŠ›å›¾ã€‚
	* é¢œè‰²æ·±æµ…ä»£è¡¨ä¿®æ”¹é¢‘ç‡ã€‚
	* æ‹–åŠ¨æ»‘å—ï¼Œç¼–è¾‘å™¨å†…å®¹æŒ‰éœ€å›æ”¾ï¼ˆåŸºäº Loro å†å²ï¼›éœ€è¦åˆ†æ®µåŠ è½½/é™çº§ä»¥é¿å…å¡é¡¿ä¸å†…å­˜å³°å€¼ï¼‰ã€‚



### 4. å‘½ä»¤é¢æ¿ (The Commander)

* å‘¼å‡ºï¼š`Cmd/Ctrl + K`ã€‚
* åŠŸèƒ½ï¼š
	* **å¯¼èˆª**ï¼š`Go to file...`ï¼ˆæ ¸å¿ƒæä¾›å‘½ä»¤ä¸è·¯ç”±ï¼›å…¨æ–‡ç´¢å¼•/æ¨¡ç³Šæœç´¢ç”±æ’ä»¶å¯é€‰æä¾›ï¼Œä¾‹å¦‚ Tantivyï¼‰ã€‚
	* **æ“ä½œ**ï¼š`Toggle Dark Mode`ã€`Git Push`ã€`Export PDF`ï¼ˆç”±æ’ä»¶æ³¨å†Œå‘½ä»¤ï¼›æ ¸å¿ƒåªæä¾›å—æ§æ‰§è¡Œä¸èƒ½åŠ›æ ¡éªŒï¼‰ã€‚
	* **æ’å…¥**ï¼š`Insert Math Block`ã€`Insert Date`ã€‚
	* **å¿«é€Ÿæ–‡ä»¶åˆ—è¡¨**ï¼šå‚è€ƒ SilverBulletï¼Œæä¾›å³æ—¶æ–‡ä»¶/ç¬”è®°åˆ—è¡¨å¼¹å‡ºï¼Œæ”¯æŒé”®ç›˜è¿‡æ»¤/è·³è½¬ã€‚



---

## ç¬¬ä¸‰ç« ï¼šç»Ÿä¸€åç«¯æ¶æ„ (The Vibranium Backend)

*(ç»§æ‰¿æ—¢æœ‰æ ¸å¿ƒï¼Œç¡®ä¿é€»è¾‘é—­ç¯)*

* **å­˜å‚¨ï¼ˆçœŸæº + æŠ•å½±ï¼‰**ï¼š
	* **åŒå­˜å‚¨**ï¼š`/data/ledger` ä¿å­˜ append-only äºŒè¿›åˆ¶æ—¥å¿—åˆ†æ®µï¼ˆ`log_001.bin`ï¼‰+ å‘¨æœŸæ€§ Snapshotï¼ˆ`snap_v100.bin`ï¼‰ã€‚
	* `/data/vault` ä¸º Markdown æŠ•å½±ç›®å½•ï¼ˆæŠ•å½±éçœŸæºï¼‰ï¼›æ”¯æŒå»¶è¿Ÿå†™/æŒ‰éœ€å†™ï¼›å¤–éƒ¨å†™å…¥ Vault MUST ç»ç”±å’Œè§£è½¬æ¢ä¸º Ops å¹¶è¿½åŠ åˆ° Ledgerã€‚

* **ç´¢å¼•ä¸æ£€ç´¢**ï¼š
	* Redb/Sled ç»´æŠ¤å…ƒæ•°æ®ã€UI Stateã€`DocId <-> Path` æ˜ å°„ã€‚
	* Tantivy å…¨æ–‡æ£€ç´¢ç´¢å¼•ä¸ºæ’ä»¶å¯é€‰èƒ½åŠ›ï¼›å¯ç”¨æ—¶å¼ºè°ƒèµ„æºä¸Šé™ä¸èŠ‚æµï¼Œé»˜è®¤ä¸è¿›å…¥æ ¸å¿ƒå¿…é€‰è·¯å¾„ã€‚

* **åŒæ­¥/æµæ§**ï¼š
	* **è¾“å…¥**ï¼šå®¢æˆ·ç«¯ Opsã€æœåŠ¡ç«¯ Opsã€Snapshotã€è®¢é˜…/å¿ƒè·³ã€‚
	* **è¾“å‡º**ï¼šå¢é‡ Ops æ¨é€æˆ– Snapshot ä¸‹å‘ï¼›åŒæ­¥çŠ¶æ€å¯è§‚æµ‹ï¼ˆè½å/è¿½å¹³/å¤±è´¥ï¼‰ã€‚
	* **çº¦æŸ**ï¼š
		* MUST æœ‰èƒŒå‹ï¼šæ‰€æœ‰æ”¶å‘é˜Ÿåˆ—æœ‰ç¡¬ä¸Šé™ï¼›è¶…é™ MUST è§¦å‘é™çº§ï¼ˆæ–­å¼€/æ”¹å‘ Snapshot/æ‹’ç»ä½ä¼˜å…ˆçº§ä»»åŠ¡ï¼‰ã€‚
		* MUST æ”¯æŒç¦»çº¿ï¼šæ–­ç½‘æœŸé—´å†™å…¥æœ¬åœ° Opsï¼›é‡è¿åä¸Šæ¨å¹¶å¯¹é½ã€‚
		* SHOULD åˆ†çº§ï¼šè½»å¾®è½åèµ° Ops replayï¼Œä¸¥é‡è½åèµ° Snapshotã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šç½‘ç»œå¤±è´¥ä¸é˜»å¡ç¼–è¾‘ï¼›é‡è¿åæœ€ç»ˆä¸€è‡´ï¼›è¿ç»­å¤±è´¥ MUST æä¾›å¯è§å‘Šè­¦ä¸æ‰‹åŠ¨é‡è¯•å…¥å£ã€‚

* **å’Œè§£ä¸å¤–éƒ¨ä¿®æ”¹**ï¼š
	* **è¾“å…¥**ï¼šVault æ–‡ä»¶å˜æ›´äº‹ä»¶ï¼ˆNotifyï¼‰+ å˜æ›´å†…å®¹ï¼ˆæˆ– diffï¼‰ã€‚
	* **è¾“å‡º**ï¼šå¯¹åº” Opsï¼ˆè¿½åŠ å†™å…¥ Ledgerï¼‰+ å¹¿æ’­â€œå¤–éƒ¨ä¿®æ”¹å·²åˆå¹¶â€ã€‚
	* **çº¦æŸ**ï¼š
		* MUST å¹‚ç­‰ï¼ˆåŒä¸€æ”¹åŠ¨ä¸é‡å¤å¸æ”¶ï¼‰ï¼›MUST é˜²æ­»å¾ªç¯ï¼ˆSentinel Lockï¼‰ã€‚
		* **MUST è¯†åˆ«é‡å‘½å**ï¼šåˆ©ç”¨ **Inode è¿½è¸ª (Linux/macOS)** æˆ– **File ID (Windows)** è¯†åˆ«æ–‡ä»¶ç§»åŠ¨/é‡å‘½åï¼Œé˜²æ­¢ DocId å†å²æ–­è£‚ã€‚
		* **MUST é˜²æŠ– (Debounce)**ï¼šå¤–éƒ¨å†™å…¥ååº”æœ‰é™é»˜æœŸï¼ˆå¦‚ 200msï¼‰ï¼Œç­‰å¾…æ–‡ä»¶å†™å…¥ç¨³å®šï¼ˆé˜² Editor ä¸´æ—¶æ–‡ä»¶/åŸå­ä¿å­˜å¹²æ‰°ï¼‰ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šæ— æ³•è§£æ/å†²çªä¸å¯åˆå¹¶æ—¶ MUST æ˜ç¡®æç¤ºå¹¶ä¿ç•™åŸå†…å®¹ï¼ˆä¸é™é»˜ä¸¢å¤±ï¼‰ã€‚

* **è¿è¡Œæ—¶å®‰å…¨ï¼ˆæ’ä»¶/è„šæœ¬ï¼‰**ï¼š
	* **è¾“å…¥**ï¼šæ’ä»¶åŒ…ï¼ˆRhai/Extismï¼‰+ èƒ½åŠ›æ¸…å• + å‘½ä»¤/äº‹ä»¶è§¦å‘ã€‚
	* **è¾“å‡º**ï¼šå—æ§ Host API è°ƒç”¨ç»“æœï¼ˆè¯»å†™/ç½‘ç»œ/æœç´¢/UI æ’æ§½ï¼‰ã€‚
	* **çº¦æŸ**ï¼šdefault denyï¼›Host Functions MUST åš Capability æ ¡éªŒã€è·¯å¾„/åŸŸåç™½åå•ä¸å®¡è®¡ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šè¶Šæƒè°ƒç”¨ MUST å¤±è´¥å¹¶å¯è¯Šæ–­ï¼›æ’ä»¶å´©æºƒ MUST éš”ç¦»ï¼Œä¸å½±å“æ ¸å¿ƒç¼–è¾‘è·¯å¾„ã€‚

### è®¤è¯ä¸ç™»å½• (Auth & Login)

* **å•ç”¨æˆ·é…ç½®**ï¼šæ— æ³¨å†Œé¡µé¢ï¼Œè´¦å·/å¯†ç æ”¾åœ¨æœåŠ¡å™¨é…ç½®æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡ä¸­ï¼Œå¯†ç ä»…å­˜ Argon2 å“ˆå¸Œï¼›æ”¯æŒç®¡ç† tokenï¼ˆå¦‚ personal access tokenï¼‰ä»¥ä¾¿è„šæœ¬æˆ– CLI ä½¿ç”¨ã€‚
* **2FA å¯é€‰**ï¼šæ”¯æŒ TOTPï¼ˆæœ¬åœ°ç”Ÿæˆï¼‰æˆ– Passkeyï¼›å¯åœ¨é…ç½®ä¸­å¼€å¯/å…³é—­ï¼›æœ¬åœ°éƒ¨ç½²é»˜è®¤å…³é—­ä½†é¢„ç•™å…¥å£ã€‚
* **å®‰å…¨åŸºçº¿**ï¼šå¼ºåˆ¶ HTTPSï¼›ç™»å½•è¡¨å•æŠ— CSRFï¼›é”™è¯¯æç¤ºä¸æš´éœ²è´¦å·å­˜åœ¨æ€§ï¼›é™åˆ¶æš´åŠ›å°è¯•ï¼ˆé€Ÿç‡é™åˆ¶ã€é”å®šæˆ–ç®€å•éªŒè¯ç å¯é€‰ï¼‰ã€‚
* **ä¼šè¯ç®¡ç†**ï¼šçŸ­æœŸè®¿é—®ä»¤ç‰Œ + é•¿æœŸåˆ·æ–°ä»¤ç‰Œï¼›å¯é€‰â€œè®°ä½æœ¬æœºâ€å»¶é•¿ä¼šè¯ï¼›æ”¯æŒä¸€é”®å¤±æ•ˆæ‰€æœ‰ä¼šè¯ã€‚
* **ä½“éªŒç»†èŠ‚**ï¼šé”®ç›˜å‹å¥½ï¼ˆå›è½¦æäº¤ã€ç„¦ç‚¹ç®¡ç†ï¼‰ã€æ˜¾ç¤º/éšè—å¯†ç ã€åŠ è½½/ç¦ç”¨æ€ã€ç§»åŠ¨ç«¯è½¯é”®ç›˜ä¸é®æŒ¡ï¼›äº®/æš—ä¸»é¢˜é€‚é…ã€‚
* **ç¦»çº¿åœºæ™¯**ï¼šç¦»çº¿ä»…å…è®¸å·²ç™»å½•è®¾å¤‡è®¿é—®æœ¬åœ°æ•°æ®ï¼›é‡è¿æ—¶è‹¥ä¼šè¯è¿‡æœŸéœ€é‡æ–°æ ¡éªŒæœ¬åœ°å­˜å‚¨çš„å‡­æ®ã€‚

---

## ç¬¬å››ç« ï¼šæ•°æ®å®Œæ•´æ€§ä¸ç¾å¤‡ (Integrity & Recovery)

* **Append-only**ï¼šæ‰€æœ‰å†™æ“ä½œè¿½åŠ è´¦æœ¬ï¼Œä¸æ”¹å†å²ï¼›åå°å®šæœŸ compactionï¼Œåˆå¹¶æ—§æ—¥å¿—ä¸º Snapshotï¼Œå›æ”¶è¿‡æœŸ Opsã€‚
* **æŠ•å½±ç­–ç•¥**ï¼šMarkdown æŠ•å½±éçœŸæºï¼Œæ­£å¸¸ä» Ledger æ¸²æŸ“ï¼ˆå¯é…ç½® 1-2 ç§’å»¶è¿Ÿæˆ–ç‰¹å®šäº‹ä»¶è§¦å‘å†™å‡ºï¼‰ï¼›å¤–éƒ¨ç¼–è¾‘ Vault æ—¶å¿…é¡»ç»â€œå’Œè§£â€å›å†™ Ledgerã€‚
* **æ¢å¤åœºæ™¯**ï¼š
	* Markdown è¯¯åˆ  -> ä» Ledger å…¨é‡é‡å»ºã€‚
	* Ledger æŸå -> åå‘å¯¼å…¥ Markdown ç”Ÿæˆæ–° Ledgerï¼ˆä¿ç°çŠ¶ï¼Œå¤±éƒ¨åˆ†å†å²ï¼‰ã€‚
	* å®¢æˆ·ç«¯é”™ä¹± -> Hard Resetï¼Œä¸¢å¼ƒæœ¬åœ° DBï¼Œé‡æ‹‰ Snapshotã€‚

* **Portable Ledger Export (ç¾éš¾æ¢å¤/é€ƒç”Ÿèˆ±)**: 
    * æä¾› `deve-note export-ledger --format=jsonl` å‘½ä»¤ï¼Œå°†äºŒè¿›åˆ¶ Ledger å¯¼å‡ºä¸ºäººç±»å¯è¯»çš„ JSON Lines æ ¼å¼ï¼ˆOps æˆ–çº¯æ–‡æœ¬å†å²ï¼‰ã€‚
    * **ç›®çš„**ï¼šç¡®ä¿å³ä½¿ä¸å†ä½¿ç”¨ Deve-Note è½¯ä»¶ï¼Œç”¨æˆ·çš„æ•°æ®ï¼ˆå«å®Œæ•´å†å²ç‰ˆæœ¬ï¼‰ä¹Ÿèƒ½ä»¥é€šç”¨æ ¼å¼è¢«è§£æå’Œè¿ç§»ã€‚è¿™æ¶ˆé™¤äº†â€œäºŒè¿›åˆ¶æ ¼å¼é”æ­»â€çš„ææƒ§ã€‚

---

## ç¬¬äº”ç« ï¼šæ•°æ®æµä¸äº¤äº’ (Interaction Flows)

### åœºæ™¯ä¸€ï¼šå¤–éƒ¨ç¼–è¾‘å™¨ååŒ (The "Alt-Tab" Flow)

1. ç”¨æˆ·åœ¨ VS Code ä¸­æ‰“å¼€ `/data/vault/thesis.md`ï¼Œä¿®æ”¹äº†ä¸€æ®µå…¬å¼ï¼Œä¿å­˜ã€‚
2. **åç«¯**: `Notify` æ•è· -> **Debounce (é˜²æŠ–)** -> **Inode æ£€æŸ¥ (ç¡®è®¤éé‡å‘½å)** -> æ£€æŸ¥é” -> è¯»å–æ–‡ä»¶ -> `Diff` -> ç”Ÿæˆ Ops -> å­˜å…¥ Redbã€‚
3. **æ¨é€**: åç«¯é€šè¿‡ WebSocket æ¨é€æ–°çš„ Ops åˆ° Deve-Note å®¢æˆ·ç«¯ã€‚
4. **å‰ç«¯**:
	* ç¼–è¾‘å™¨å…‰æ ‡ä½ç½®**ä¿æŒä¸å˜**ã€‚
	* ä¿®æ”¹çš„å†…å®¹åœ¨è§†å›¾ä¸­**å¹³æ»‘æ›´æ–°**ï¼ˆFlash Highlight æ•ˆæœï¼‰ã€‚
	* å³ä¸‹è§’ Toast æç¤º: *"External change merged (2ms ago)"*ã€‚



### åœºæ™¯äºŒï¼šæ•°å­¦å…¬å¼ç¼–å†™ (The Math Flow)

1. ç”¨æˆ·è¾“å…¥ `$$`ã€‚
2. **å‰ç«¯**: ç«‹å³åˆ‡æ¢ä¸ºâ€œå…¬å¼ç¼–è¾‘å—â€ï¼Œå¯ç”¨ç­‰å®½å­—ä½“ã€‚
3. **è¾“å…¥**: `\int_{a}^{b} x^2 dx`ã€‚
4. **é¢„è§ˆ**: ç¼–è¾‘å—ä¸‹æ–¹å®æ—¶æ˜¾ç¤º KaTeX æ¸²æŸ“ç»“æœã€‚
5. **å®Œæˆ**: `Ctrl+Enter` è·³å‡ºï¼Œæºç æŠ˜å ï¼Œåªæ˜¾ç¤ºæ¸²æŸ“åçš„ SVG å›¾ç‰‡ï¼ˆç‚¹å‡»å¯å†æ¬¡ç¼–è¾‘ï¼‰ã€‚

### åœºæ™¯ä¸‰ï¼šGit åŒæ­¥ (The Git Flow)

1. ç”¨æˆ·ç‚¹å‡»çŠ¶æ€æ çš„ "Git" å›¾æ ‡ï¼Œæˆ– `Cmd+K` -> `Git Sync`ã€‚
2. **å‰ç«¯**: å¼¹çª—æ˜¾ç¤ºå·®å¼‚ç»Ÿè®¡ "+12 / -5"ã€‚
3. **æƒé™æ£€æŸ¥**: Commander æ ¡éªŒèƒ½åŠ›æ¸…å•æ˜¯å¦åŒ…å« `sys.git` ä¸”è¿œç«¯ä»“åº“åœ¨ç™½åå•ã€‚
4. **è°ƒç”¨**: è§¦å‘ Rhai è„šæœ¬ `git_sync.rhai`ï¼ŒHost Functions åªå…è®¸æ¨é€åˆ°é…ç½®çš„ `GITHUB_REPO`ï¼Œç¦æ­¢æ”¹ remoteã€‚
5. **åç«¯**: æ‰§è¡Œ `git add .` -> `git commit` -> `git push`ã€‚
6. **åé¦ˆ**: çŠ¶æ€æ è½¬åœˆ -> å˜ç»¿ "Synced"ã€‚

---

## ç¬¬å…­ç« ï¼šæŠ€æœ¯æ ˆæ¸…å• (The Full Stack)

| å±‚æ¬¡ | æ ¸å¿ƒæŠ€æœ¯ | é€‰å‹ç†ç”± |
| --- | --- | --- |
| **è¯­è¨€** | Rust (2024) | å…¨æ ˆç»Ÿä¸€ã€‚ |
| **å‰ç«¯æ¡†æ¶** | **Leptos v0.7** | ä¿¡å·é©±åŠ¨ï¼Œæ€§èƒ½æè‡´ï¼Œæ—  Virtual DOM å¼€é”€ã€‚ï¼ˆ*æ³¨ï¼šéœ€ä¼˜å…ˆéªŒè¯ä¸ CodeMirror çš„é›†æˆæµç•…åº¦*ï¼‰ |
| **UI ç»„ä»¶** | **Tailwind CSS** | åŸå­åŒ– CSSï¼Œé…åˆ Shadcn-UI (Leptos port) å®ç°ä¸€è‡´æ€§è®¾è®¡ã€‚ |
| **ç¼–è¾‘å™¨** | **CodeMirror 6ï¼ˆé»˜è®¤ï¼‰/ Milkdownï¼ˆå¯é€‰ï¼‰** | è½»æ ¸å¿ƒä¿è¯æ€§èƒ½ä¸å¯¼å‡ºç¨³å®šï¼›é‡ç¼–è¾‘å™¨æŒ‰éœ€å¯ç”¨ã€‚ï¼ˆ*æ³¨ï¼šLeptos ç»‘å®šå±‚éœ€è‡ªè¡Œå°è£…æˆ–åŸå‹éªŒè¯*ï¼‰ |
| **å›¾æ ‡åº“** | **Lucide Icons** | ç»Ÿä¸€ã€ç°ä»£çš„ SVG å›¾æ ‡é›†ã€‚ |
| **å›¾è°±æ¸²æŸ“ï¼ˆå¯é€‰ï¼‰** | **Pixi.js** æˆ– **Cosmic-Graph (Rust)** | WebGL åŠ é€Ÿçš„å›¾å¯è§†åŒ–ã€‚ |
| **å­˜å‚¨** | **Redb/Sled** | çº¯ Rust åµŒå…¥å¼ DBï¼Œç´¢å¼• Ledger/Path æ˜ å°„ã€‚ |
| **æœç´¢ï¼ˆå¯é€‰ï¼‰** | **Tantivy** | å…¨æ–‡æ£€ç´¢å¼•æ“ï¼ˆé»˜è®¤ä¸è¿›å…¥æ ¸å¿ƒå¿…é€‰è·¯å¾„ï¼‰ã€‚ |
| **åŒæ­¥/æµæ§** | **Axum + Tower** | èƒŒå‹ã€é™æµã€è¶…æ—¶ã€ç†”æ–­ã€‚ |
| **å’Œè§£** | **Notify + Dissimilar** | æ–‡ä»¶ç›‘å¬ä¸ Diffã€‚ |
| **æ„å»º** | **Tauri v2** | è·¨å¹³å°å¤–å£³ã€‚ |
| **æ’ä»¶** | **Rhai + Extism** | Wasm/è„šæœ¬å¼•æ“ï¼Œèƒ½åŠ›å—æ§ã€‚ |

**æ ¸å¿ƒæ•°æ®ç»“æ„**ï¼š

* `struct DocId(Uuid);`
* `struct LedgerEntry { op: Vec<u8>, timestamp: i64, user_id: Uuid }`
* `struct CapabilityManifest { allow_net: Vec<String>, allow_fs_read: Vec<PathBuf>, allow_fs_write: Vec<PathBuf>, allow_env: Vec<String> }`

**èƒ½åŠ›æ¸…å•ç¤ºä¾‹**ï¼š

```toml
[capabilities]
allow_net = ["api.github.com"]
allow_fs_read = ["/notes/public"]
allow_fs_write = ["/notes/public"]
allow_env = ["GITHUB_TOKEN"]
```

---

### Markdown å…¼å®¹æ€§ä¸å›å½’æ¸…å• (Compatibility Checklist)

* **å¯¼å‡ºåŸåˆ™**ï¼šæ‰€æœ‰å¯¼å‡º/æŠ•å½±å¿…é¡»æ˜¯é€šç”¨ Markdownï¼ˆGFM + YAML Frontmatterï¼‰ï¼Œä¸è¾“å‡ºä»»ä½•ç§æœ‰è¯­æ³•ï¼›æ— æ³•è¡¨è¾¾çš„å¯Œæ–‡æœ¬ä¿¡æ¯åªä¿å­˜åœ¨ Ledgerã€‚
* **è¯­æ³•åŸºçº¿**ï¼šæ ‡é¢˜ã€æ®µè½ã€åˆ—è¡¨/ä»»åŠ¡åˆ—è¡¨ã€å¼•ç”¨ã€è¡¨æ ¼ã€ä»£ç å—ï¼ˆfenced + language infoï¼‰ã€é“¾æ¥ã€å›¾ç‰‡ã€è„šæ³¨ã€è¡Œå†…/å—çº§æ•°å­¦ã€Frontmatterã€‚
* **é“¾æ¥çº¦å®š**ï¼šè¿è¡Œæ—¶å†…éƒ¨é“¾æ¥ä»¥ DocId ä¸ºçœŸæºï¼ˆå¦‚ `doc://<uuid>` æˆ– `[[title]]` ç”±æ ¸å¿ƒè§£æä¸º DocIdï¼‰ï¼›å¯¼å‡ºæ—¶å¯é€‰æ‹©â€œè§£æä¸ºç›¸å¯¹è·¯å¾„ Markdown é“¾æ¥â€æˆ–â€œä¿ç•™ wiki linkï¼ˆå¯é…ç½®ï¼‰â€ã€‚
* **èµ„äº§çº¦å®š**ï¼šè¿è¡Œæ—¶å¯ç”¨ `asset://<uuid>`ï¼›å¯¼å‡ºæ—¶å¿…é¡»è½ä¸ºæ ‡å‡† Markdown å›¾ç‰‡/é“¾æ¥å¼•ç”¨ï¼ˆç›¸å¯¹è·¯å¾„æˆ–å¯é…ç½®çš„ `base_url`ï¼‰ã€‚
* **å›å½’ç”¨ä¾‹**ï¼šç»´æŠ¤ä¸€ç»„ fixture æ–‡æ¡£ï¼ˆæ•°å­¦/è¡¨æ ¼/è„šæ³¨/ä»£ç å—/å¤§æ–‡ä»¶/å¤§é‡é“¾æ¥/å¤§é‡å›¾ç‰‡ï¼‰ï¼ŒCI å¯¹æ¸²æŸ“ä¸å¯¼å‡ºåšå¿«ç…§å¯¹æ¯”ã€‚

### æ€§èƒ½é¢„ç®—ä¸æè‡´ç˜¦èº« (Performance & Footprint)

* **å‰ç«¯é»˜è®¤ç­–ç•¥**ï¼šé¦–å±åªåŠ è½½ç¼–è¾‘å™¨ + å¯¼èˆªï¼›å›¾è°±/æ—¶å…‰è½´/AI/æ’ä»¶ UI æŒ‰éœ€åŠ è½½ï¼›å¤§æ–‡æ¡£æ¸²æŸ“ä¸æ•°å­¦æ¸²æŸ“å¿…é¡»è™šæ‹ŸåŒ–ã€‚
* **ä½“ç§¯æ§åˆ¶**ï¼šé»˜è®¤ KaTeXï¼ˆé¿å… MathJax ä½“ç§¯ä¸è¿è¡Œæ—¶å¼€é”€ï¼‰ï¼›Wasm/JS åˆ†åŒ…ï¼ˆcode splittingï¼‰+ tree-shakingï¼›ç”Ÿäº§æ„å»ºå¯ç”¨ LTO/stripï¼›æŒ‰ feature flags è£å‰ªéæ ¸å¿ƒæ¨¡å—ã€‚
* **å†…å­˜é¢„ç®—ï¼ˆç›®æ ‡ï¼‰**ï¼šç©ºé—²æ€ < 150MBï¼›æ‰“å¼€ 10k è¡Œ Markdown < 300MBï¼›å…¬å¼/å›¾è°±æ¸²æŸ“ä¸å¾—å¸¸é©»å…¨é‡ç¼“å­˜ï¼Œé‡‡ç”¨ LRU/åˆ†é¡µã€‚
* **æ•°å­¦æ¸²æŸ“ç­–ç•¥**ï¼šä»…æ¸²æŸ“å¯è§†åŒºåŸŸå…¬å¼ï¼›æ¸²æŸ“ç»“æœæŒ‰å—ç¼“å­˜ï¼ˆLRU + ç¡¬ä¸Šé™ï¼‰ï¼›æ»šåŠ¨æ—¶å»¶è¿Ÿæ¸²æŸ“ï¼Œé¿å…å°–å³°å¡é¡¿ã€‚
* **åŒæ­¥/ç´¢å¼•é¢„ç®—**ï¼šWebSocket æ”¶å‘é˜Ÿåˆ—é•¿åº¦å¯é…ç½®ä¸”æœ‰ç¡¬ä¸Šé™ï¼›ç´¢å¼•èƒ½åŠ›ä»…åœ¨å¯ç”¨ç›¸åº”æ’ä»¶/feature æ—¶ç”Ÿæ•ˆï¼Œä¸”ç´¢å¼•æ›´æ–°å¿…é¡»èŠ‚æµ/æ‰¹å¤„ç†ï¼ˆé¿å…æ¯æ¬¡ä¿å­˜éƒ½è§¦å‘é‡å»ºï¼‰ï¼›è‹¥ä½¿ç”¨ Tantivyï¼Œç´¢å¼•æ”¯æŒ mmap/åˆ†æ®µåˆå¹¶å¹¶è®¾ç½®å†…å­˜ä¸Šé™ï¼›åå°ä»»åŠ¡ï¼ˆæŠ•å½±/ç´¢å¼•/å‹ç¼©ï¼‰å¿…é¡»é™å¹¶å‘ã€‚
* **Low-Spec Server Profile (512MB RAM)**: 
    *   **CSR Only**: åœ¨ä½é…æ¨¡å¼ä¸‹ **MUST** è‡ªåŠ¨ç¦ç”¨æœåŠ¡ç«¯æ¸²æŸ“ (SSR)ï¼Œä»…ä¸‹å‘é™æ€ HTML + Wasmï¼Œå°†æ¸²æŸ“è´Ÿè½½è½¬ç§»è‡³å®¢æˆ·ç«¯ã€‚
    *   **No Search Index**: é»˜è®¤å…³é—­ Tantivy æˆ–é™åˆ¶å…¶å †å†…å­˜ < 50MBã€‚
    *   **Snapshot Pruning (å¿«ç…§è£å‰ª)**ï¼šä¿ç•™æœ€è¿‘ 10 ä¸ªå¿«ç…§ + æ¯æ—¥/æ¯å‘¨å½’æ¡£ï¼Œæ—§å¿«ç…§æ¿€è¿›æ¸…ç†ï¼Œé˜²æ­¢ç£ç›˜/ç´¢å¼•è†¨èƒ€ã€‚
    *   **Cross-Compilation**: æ˜ç¡®å‘ŠçŸ¥ç”¨æˆ·ï¼Œ512MB æœåŠ¡å™¨ä»…ç”¨äº**è¿è¡Œ**ï¼Œæ„å»º (Build) å¿…é¡»åœ¨é«˜æ€§èƒ½æœºå™¨æˆ– CI ä¸Šå®Œæˆã€‚

* **Standard Server Profile (1GB+ RAM)**:
    *   **Full Features**: æ”¯æŒå…¨åŠŸèƒ½å¼€å¯ï¼ŒåŒ…æ‹¬ SSRï¼ˆæœåŠ¡ç«¯æ¸²æŸ“ï¼‰ã€Tantivy å…¨æ–‡æ£€ç´¢ã€å›¾è°±åˆ†æä¸ LaTeX é¢„æ¸²æŸ“ç¼“å­˜ã€‚
    *   **æ¨èé…ç½®**ï¼š1GB RAM å³å¯æµç•…è¿è¡Œå®Œæ•´ç‰ˆï¼ˆDocker é™åˆ¶å»ºè®®è®¾ä¸º 1024Mï¼‰ï¼›2GB+ RAM å¯æ”¯æŒæ›´æ¿€è¿›çš„ç¼“å­˜ä¸å¤§æ–‡ä»¶ç´¢å¼•ã€‚

### Server Configuration Profiles & Feature Flags (é…ç½®æ¸…å•)

ç³»ç»Ÿæä¾›ç²¾ç»†çš„é…ç½®å¼€å…³ï¼Œä»¥é€‚é…ä»æ ‘è“æ´¾ (Low-Spec) åˆ°é«˜æ€§èƒ½æœåŠ¡å™¨ (Standard) çš„ä¸åŒç¯å¢ƒã€‚

| ç¯å¢ƒå˜é‡ / é…ç½®é¡¹ | é»˜è®¤å€¼ (Standard) | 512MB æ¨èå€¼ (Low-Spec) | åŠŸèƒ½å½±å“è¯´æ˜ |
| :--- | :--- | :--- | :--- |
| `DEVE_PROFILE` | `standard` | `low-spec` | **ä¸€é”®é¢„è®¾**ã€‚è®¾ç½®ä¸º `low-spec` æ—¶ï¼Œä¼šè‡ªåŠ¨è¦†ç›–ä¸‹è¡¨çš„é»˜è®¤å€¼ä¸ºæ¨èå€¼ã€‚ |
| `FEATURE_SSR` | `true` | `false` | **æœåŠ¡ç«¯æ¸²æŸ“**ã€‚`false` = ä»…ä¸‹å‘ HTML éª¨æ¶ï¼Œæµè§ˆå™¨åŠ è½½ WASM åæ¸²æŸ“ã€‚æå¤§é™ä½æœåŠ¡å™¨å†…å­˜å³°å€¼ï¼Œä½†é¦–å±åŠ è½½ç¨æ…¢ã€‚ |
| `FEATURE_SEARCH` | `true` | `false` | **å…¨æ–‡æœç´¢ (Tantivy)**ã€‚`false` = ä»…æ”¯æŒæ–‡ä»¶åæœç´¢ã€‚ç¦ç”¨ Tantivy å¼•æ“å¯èŠ‚çœ 50-150MB å †å†…å­˜ä¸ CPU çªå‘å ç”¨ã€‚ |
| `FEATURE_GRAPH` | `true` | `false` | **å…¨åŸŸå›¾è°±åå°åˆ†æ**ã€‚`false` = æœåŠ¡å™¨ä¸æ„å»ºå¼•ç”¨å›¾è°±æ•°æ®ï¼Œå‰ç«¯å›¾è°±å¯è§†åŒ–åŠŸèƒ½å°†ä¸å¯ç”¨ã€‚ |
| `MEM_CACHE_MB` | `128` | `32` | **å†…å­˜ç¼“å­˜ä¸Šé™**ã€‚ç”¨äºå›¾ç‰‡ç¼©ç•¥å›¾ã€LaTeX æ¸²æŸ“ç»“æœçš„ LRU ç¼“å­˜å¤§å°ã€‚ |
| `CONCURRENCY` | `4` | `1` | **åå°å¹¶å‘åº¦**ã€‚æ§åˆ¶ç´¢å¼•æ„å»ºã€å‹ç¼©ã€å¯¼å…¥ç­‰é‡ä»»åŠ¡çš„æœ€å¤§å¹¶å‘çº¿ç¨‹æ•°ã€‚ |
| `SNAPSHOT_DEPTH` | `100` | `10` | **å¿«ç…§ä¿ç•™æ·±åº¦**ã€‚ä¿ç•™æœ€è¿‘å¤šå°‘ä¸ªç‰ˆæœ¬çš„å¿«ç…§ã€‚å‡å°‘æ•°é‡å¯æ˜¾è‘—é™ä½ Redb ç´¢å¼•å¤§å°ã€‚ |

* **Ledger ä¸èµ„äº§ I/O**ï¼šè¯»å†™å¿…é¡»æµå¼ï¼ˆstreamingï¼‰ï¼Œé¿å…æ•´æ–‡ä»¶è½½å…¥å†…å­˜ï¼›Snapshot/æ—¥å¿—æ®µå¯é€‰ zstd å‹ç¼©ï¼ˆä»¥æ®µä¸ºå•ä½ï¼‰ï¼Œä¸ç ´å append-only è¯­ä¹‰ã€‚
* **æ’ä»¶/AI èµ„æºé™åˆ¶**ï¼šæ’ä»¶ä¸ AI ä½œä¸šç»Ÿä¸€è¿›å…¥ä½œä¸šé˜Ÿåˆ—ï¼Œå…·å¤‡è¶…æ—¶/å–æ¶ˆï¼›é»˜è®¤å¹¶å‘ä½ä¸”å¯é…ç½®ï¼›ä»»ä½•æ‰©å±•ä¸å¾—é˜»å¡ç¼–è¾‘ä¸»çº¿ç¨‹ã€‚

---

## ç¬¬ä¸ƒç« ï¼šæ’ä»¶è¿è¡Œæ—¶ä¸èµ„äº§æ¨¡å‹ (Plugin Runtime & Assets)

* **æ’ä»¶ ABI ä¸ç”Ÿå‘½å‘¨æœŸ**ï¼š
	* **è¾“å…¥**ï¼šæ’ä»¶æ¸…å•ï¼ˆåç§°/ç‰ˆæœ¬/èƒ½åŠ›/å…¥å£ï¼‰+ install/activate/deactivate + äº‹ä»¶è®¢é˜…ã€‚
	* **è¾“å‡º**ï¼šå‘½ä»¤æ³¨å†Œã€äº‹ä»¶å›è°ƒã€å¯é€‰ UI æ’æ§½æ‰©å±•ã€‚
	* **çº¦æŸ**ï¼šæ’ä»¶åªèƒ½è®¢é˜…å·²å£°æ˜äº‹ä»¶ï¼›æ ¸å¿ƒäº‹ä»¶æµ MUST å¯å–æ¶ˆ/å¯é™æµã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šåŠ è½½å¤±è´¥/ç‰ˆæœ¬ä¸å…¼å®¹ MUST æ˜ç¡®æŠ¥é”™ï¼›ä¸å¾—å½±å“æ ¸å¿ƒç¼–è¾‘è·¯å¾„ã€‚

* **Host Functionsï¼ˆå—æ§ APIï¼‰**ï¼š
	* **è¾“å…¥**ï¼šæŒ‰ DocId çš„è¯»å†™ã€æœç´¢ã€å‘½ä»¤æ³¨å†Œã€ç½‘ç»œè¯·æ±‚ã€‚
	* **è¾“å‡º**ï¼šç¡®å®šæ€§ç»“æœæˆ–ç»“æ„åŒ–é”™è¯¯ã€‚
	* **çº¦æŸ**ï¼šæ‰€æœ‰è°ƒç”¨ MUST ç»è¿‡ Capability æ ¡éªŒä¸ç™½åå•ï¼›æ•æ„Ÿè°ƒç”¨ MUST å¯å®¡è®¡ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šè¶Šæƒ MUST å¤±è´¥ï¼›é”™è¯¯ MUST å¯å®šä½åˆ°æ’ä»¶ä¸èƒ½åŠ›é¡¹ã€‚

* **Plugin RPC Bridge (å‰ç«¯-åç«¯é€šä¿¡)**ï¼š
    * æ’ä»¶é€šå¸¸åŒ…å«å‰ç«¯ UIï¼ˆJS/Wasmï¼‰ä¸åç«¯é€»è¾‘ï¼ˆRhai/Wasmï¼‰ã€‚
    * **æœºåˆ¶**ï¼šæä¾›æ ‡å‡†åŒ–çš„ `client.call("plugin_id", "fn_name", args)` æ–¹æ³•ï¼Œé€šè¿‡ WebSocket é€æ˜è½¬å‘è‡³åç«¯æ’ä»¶è¿è¡Œæ—¶ã€‚
    * **å®‰å…¨**ï¼šRPC è°ƒç”¨éµå¾ªåŒæ ·çš„ Capability æ£€æŸ¥ï¼›å‰ç«¯ä¾§åªèƒ½å‘èµ·è°ƒç”¨ï¼Œåç«¯ä¾§æ‰§è¡Œå®é™…çš„æ•æ„Ÿæ“ä½œï¼ˆå¦‚æ–‡ä»¶è¯»å†™/Git Pushï¼‰ã€‚

* **èµ„æºé…é¢ä¸éš”ç¦»**ï¼š
	* **è¾“å…¥**ï¼šæ’ä»¶ä»»åŠ¡ä¸æ‰§è¡Œè¯·æ±‚ã€‚
	* **è¾“å‡º**ï¼šä»»åŠ¡ç»“æœæˆ–è¶…æ—¶/å–æ¶ˆã€‚
	* **çº¦æŸ**ï¼šCPU/å†…å­˜/å¹¶å‘/è¶…æ—¶ MUST å¯é…ç½®ä¸”é»˜è®¤ä¿å®ˆï¼›å´©æºƒéš”ç¦» MUST ç”Ÿæ•ˆã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šè¶…æ—¶/å–æ¶ˆ MUST å¯æ¢å¤ï¼›åå¤å¼‚å¸¸ MAY è‡ªåŠ¨åœç”¨æ’ä»¶ã€‚

* **èµ„äº§æ¨¡å‹ä¸å¯¼å‡º**ï¼š
	* **è¾“å…¥**ï¼šèµ„äº§å†™å…¥ï¼ˆå›¾ç‰‡/é™„ä»¶/æ¸²æŸ“äº§ç‰©ï¼‰ã€å¼•ç”¨åˆ›å»ºã€å¯¼å‡ºè¯·æ±‚ã€‚
	* **è¾“å‡º**ï¼šè¿è¡Œæ—¶ `asset://<uuid>`ï¼›å¯¼å‡ºä¸ºæ ‡å‡† Markdown å›¾ç‰‡/é“¾æ¥å¼•ç”¨ã€‚
	* **çº¦æŸ**ï¼šèµ„äº§ MUST æœ‰ DocIdï¼›å¯¼å‡º MUST ä¸å†™å…¥ç§æœ‰æ ¼å¼ï¼›é“¾æ¥ MAY é€‰ç›¸å¯¹è·¯å¾„æˆ– `base_url`ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šèµ„äº§ç¼ºå¤± MUST å¯è¯Šæ–­ï¼ˆèƒ½å®šä½ç¼ºå¤± DocId ä¸å¼•ç”¨ä½ç½®ï¼‰ã€‚

* **äº§ç‰©å†™å›ï¼ˆè®¡ç®—/æ¸²æŸ“ç±»ï¼‰**ï¼š
	* **è¾“å…¥**ï¼šè®¡ç®—/æ¸²æŸ“ç»“æœï¼ˆäºŒè¿›åˆ¶æˆ–æ–‡æœ¬ï¼‰ã€‚
	* **è¾“å‡º**ï¼šå†™å…¥èµ„äº§å­˜å‚¨ï¼ˆç”Ÿæˆ DocIdï¼‰å¹¶è¿”å›å¯æ’å…¥çš„ Markdown å¼•ç”¨ã€‚
	* **çº¦æŸ**ï¼šå†™å› MUST åŸå­åŒ–ï¼ˆè¦ä¹ˆæˆåŠŸå¹¶å¯å¼•ç”¨ï¼Œè¦ä¹ˆå¤±è´¥å¹¶å¯é‡è¯•ï¼‰ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šå¤±è´¥ MUST ä¸æ±¡æŸ“æ–‡æ¡£æ­£æ–‡ï¼ˆä¸æ’å…¥åå¼•ç”¨ï¼‰ã€‚

### å¯æ‰§è¡Œä»£ç å—æ‰©å±• (RStudio/Knitr-style Fenced Blocks)

* **è¾“å…¥**ï¼šå½¢å¦‚ ```` ```{latex} ```` / ```` ```{r} ```` / ```` ```{python} ```` çš„ fenced block +ï¼ˆå¯é€‰ï¼‰å‚æ•°ã€‚
* **è¾“å‡º**ï¼šçº¯æ–‡æœ¬ã€Markdown ç‰‡æ®µæˆ–èµ„äº§ DocIdï¼›æ ¸å¿ƒå›å†™ä¸ºâ€œç´§é‚»è¾“å‡ºå—â€æˆ–â€œèµ„äº§å¼•ç”¨â€ã€‚
* **çº¦æŸ**ï¼š
	* æ ¸å¿ƒåªè¯†åˆ«ä¸è·¯ç”±ï¼›æœªå®‰è£…æ’ä»¶ MUST æŒ‰æ™®é€šä»£ç å—æ˜¾ç¤ºã€‚
	* æ‰§è¡Œ MUST è¿›å…¥ä½œä¸šé˜Ÿåˆ—ï¼Œå¹¶å—èƒ½åŠ›æ¸…å•ä¸é…é¢çº¦æŸï¼ˆè¶…æ—¶/å–æ¶ˆ/å¹¶å‘ä¸Šé™ï¼‰ã€‚
* **å¤±è´¥è¯­ä¹‰**ï¼šå¤±è´¥ MUST ç”Ÿæˆå¯æŠ˜å æ—¥å¿—ä¸é”™è¯¯æ‘˜è¦ï¼›ä¸å¾—æ”¹å†™åŸ fenced blockï¼›ç¼“å­˜å‘½ä¸­/å¤±æ•ˆ MUST å¯è§£é‡Šã€‚

---

## ç¬¬å…«ç« ï¼šAI ä¸è®¡ç®—æ‰©å±• (AI & Compute Extensions)

* **AI æŠ½è±¡å±‚**ï¼š
	* **è¾“å…¥**ï¼šprovider/æ¨¡å‹é€‰æ‹© + æç¤ºè¯/ä¸Šä¸‹æ–‡ +ï¼ˆå¯é€‰ï¼‰å·¥å…·è°ƒç”¨è¯·æ±‚ã€‚
	* **è¾“å‡º**ï¼šæµå¼æ–‡æœ¬ã€ç»“æ„åŒ–å‡½æ•°è°ƒç”¨ã€æˆ–èµ„äº§ DocIdï¼ˆå›¾åƒ/æ¸²æŸ“äº§ç‰©ï¼‰ï¼›ä¸æ±¡æŸ“ Markdown å¯¼å‡ºæ ¼å¼ã€‚
	* **çº¦æŸ**ï¼šæ¥å£ MUST provider-agnosticï¼ˆ`AiClient/ModelRegistry`ï¼‰ï¼›MUST æ”¯æŒæµå¼ä¸é€Ÿç‡é™åˆ¶ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šå¤±è´¥ MUST å¯æ¢å¤ï¼ˆé‡è¯•/åˆ‡æ¢ providerï¼‰ä¸”å¯è§‚æµ‹ï¼ˆçŠ¶æ€æ /æ—¥å¿—ï¼‰ã€‚

* **å®‰å…¨ä¸èƒ½åŠ›ç»‘å®š**ï¼š
	* **è¾“å…¥**ï¼šAI è®¿é—®ç½‘ç»œ/æ–‡ä»¶/å·¥å…·çš„è¯·æ±‚ã€‚
	* **è¾“å‡º**ï¼šå…è®¸/æ‹’ç»çš„å†³ç­–ä¸å®¡è®¡è®°å½•ã€‚
	* **çº¦æŸ**ï¼šé»˜è®¤æ— æƒè®¿é—®æœ¬åœ°æ–‡ä»¶ï¼›ç½‘ç»œåŸŸåã€æ–‡ä»¶è¯»å†™ã€å·¥å…·è°ƒç”¨å¿…é¡»æ˜¾å¼æˆæƒã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šæ‹’ç» MUST æ˜ç¡®åˆ°å…·ä½“èƒ½åŠ›é¡¹ï¼›ä¸å¾—é™é»˜é™æƒã€‚

* **è®¡ç®—/æ¸²æŸ“ä½œä¸š**ï¼š
	* **è¾“å…¥**ï¼šé•¿ä»»åŠ¡ï¼ˆAIã€æ¸²æŸ“ã€ç´¢å¼•ç­‰ï¼‰ã€‚
	* **è¾“å‡º**ï¼šç»“æœï¼ˆæ–‡æœ¬/èµ„äº§ DocIdï¼‰+ å¯æŠ˜å æ—¥å¿—ã€‚
	* **çº¦æŸ**ï¼šMUST è¿›å…¥ä½œä¸šé˜Ÿåˆ—ï¼ˆè¶…æ—¶/å–æ¶ˆ/é‡è¯•/å¹¶å‘ä¸Šé™ï¼‰ã€‚
	* **å¤±è´¥è¯­ä¹‰**ï¼šå¤±è´¥ MUST å¯é‡è¯•ä¸”ä¸é˜»å¡ç¼–è¾‘ä¸»çº¿ç¨‹ã€‚

* **éšç§ä¸é¥æµ‹**ï¼šé»˜è®¤å…³é—­ï¼›å¼€å¯æ—¶ MUST å£°æ˜æ”¶é›†å­—æ®µä¸ç”¨é€”ï¼Œå¹¶æä¾›å…³é—­å¼€å…³ã€‚

---

## ç¬¬ä¹ç« ï¼šå¤šç«¯å‘å¸ƒä¸å°è£…ç­–ç•¥ (Cross-Platform Delivery)

* **å•å†…æ ¸ï¼Œå¤šå¤–å£³**ï¼šæ ¸å¿ƒé€»è¾‘ (CRDT/Ledgerã€VFSã€æƒé™ã€åŒæ­¥åè®®ã€åŠ å¯†) å‡åœ¨çº¯ Rust crate ä¸­å®ç°ï¼Œæ— å¹³å°ç»‘å®šï¼›ç¼–è¯‘ä¸º wasm (web)ã€é™æ€/åŠ¨æ€åº“ (æ¡Œé¢/ç§»åŠ¨) å…±ç”¨åŒä¸€å¥—ä»£ç ã€‚
* **UI å¤ç”¨**ï¼šLeptos + Wasm ä½œä¸º UI/çŠ¶æ€å±‚ï¼›ç»„ä»¶ä¿æŒå¹³å°æ— å…³ï¼Œå¹³å°å·®å¼‚é€šè¿‡æè–„é€‚é…å±‚æ³¨å…¥ï¼ˆæ–‡ä»¶å¯¹è¯æ¡†ã€å‰ªè´´æ¿ã€é€šçŸ¥ã€çª—å£ï¼‰ã€‚
* **å¤–å£³é€‚é…**ï¼š
  * Desktop (Windows/Linux/macOS)ï¼šTauri v2 æä¾›çª—å£/èœå•/æ‰˜ç›˜/æ–‡ä»¶è®¿é—®ã€‚
  * Webï¼šçº¯æµè§ˆå™¨/PWAï¼Œç›´æ¥ä½¿ç”¨ wasm ç‰ˆæœ¬æ ¸å¿ƒ + Leptosã€‚
  * Mobile (Android/iOS)ï¼šTauri Mobile / WebView å¤–å£³ + Rust æ ¸å¿ƒé™æ€åº“ï¼›
    * **UI ç­–ç•¥**ï¼šä¸ç›´æ¥ç§»æ¤æ¡Œé¢ç‰ˆâ€œé©¾é©¶èˆ±â€ã€‚ç§»åŠ¨ç«¯ **MUST** é‡‡ç”¨ç®€åŒ–çš„ **"Reader/Capture Mode"**ï¼Œä¸“æ³¨äºé˜…è¯»å’Œå¿«é€Ÿè®°å½•ï¼Œé¿å…å¤æ‚çš„å¿«æ·é”®ä¸å¤šé¢æ¿äº¤äº’ã€‚
    * å¿…è¦æ—¶ç”¨ Capacitor/FFI æä¾›ç³»ç»Ÿæƒé™ã€æ–‡ä»¶é€‰æ‹©ã€é€šçŸ¥ã€‚
* **å­˜å‚¨é€‚é…**ï¼šå®šä¹‰ `Storage` traitï¼Œæ¡Œé¢ç”¨ sqlite/Redbï¼Œç§»åŠ¨ç”¨ sqlite/IndexedDBï¼ŒWeb ç”¨ IndexedDBï¼›VFS ä»ä»¥ `DocId` ä¸ºä¸»é”®ï¼Œè·¯å¾„ä¸ºå±æ€§ã€‚
* **ç½‘ç»œé€‚é…**ï¼šå®šä¹‰ `NetClient` traitï¼Œç»Ÿä¸€ WebSocket/HTTPï¼›Web/ç§»åŠ¨ä½¿ç”¨æµè§ˆå™¨ APIï¼Œæ¡Œé¢/CLI ä½¿ç”¨ reqwest/tungsteniteã€‚
* **æƒé™ä¸èƒ½åŠ›**ï¼šèƒ½åŠ›æ¸…å•ç”±æ ¸å¿ƒæ ¡éªŒï¼Œå¤–å£³è´Ÿè´£è¯·æ±‚ OS æƒé™ï¼ˆæ–‡ä»¶/ç½‘ç»œ/é€šçŸ¥ç­‰ï¼‰ï¼›Host Functions ä»åšè·¯å¾„å’ŒåŸŸåç™½åå•ã€‚
* **æ„å»ºä¸ CI**ï¼šå•ä»“å¤šç›®æ ‡ Workspaceï¼›CI matrix è¦†ç›– windows/linux/macos + wasm32-unknown-unknown + aarch64-apple-ios + aarch64-linux-androidï¼›äº§å‡º Tauri bundleã€PWAã€Android/iOS åŒ…ã€‚

* **æè‡´å‹ç¼©å¼€å…³**ï¼šé»˜è®¤ä¸ç¼–è¯‘/ä¸åŠ è½½å›¾è°±ä¸æ—¶å…‰è½´ç­‰é‡æ¨¡å—ï¼ˆå¯é€šè¿‡ feature/æ’ä»¶å¯ç”¨ï¼‰ï¼›AI ç›¸å…³ä¾èµ–ä¸ UI ç»„ä»¶é»˜è®¤æŒ‰éœ€åŠ è½½ï¼›ç§»åŠ¨ç«¯ä¸ Web ä¼˜å…ˆé€‰æ‹©è½»é‡æ¸²æŸ“è·¯å¾„ã€‚

---

## ç¬¬åç« ï¼šå¼€æºå‘å¸ƒä¸ç¤¾åŒºè¿è¥ (Open Source Playbook)

* **è®¸å¯è¯**ï¼šæ¨è MIT æˆ– Apache-2.0ï¼›ç¡®ä¿ä¾èµ–é“¾å…¼å®¹ï¼Œé™„å¸¦ç¬¬ä¸‰æ–¹ NOTICEã€‚
* **è´¡çŒ®æµç¨‹**ï¼šæä¾› CONTRIBUTINGã€Code of Conductï¼›è§„èŒƒ PR æ¨¡æ¿ã€Issue æ¨¡æ¿ï¼›å¼ºåˆ¶ CIï¼ˆlint/testï¼‰é€šè¿‡ååˆå¹¶ã€‚
* **å‘è¡ŒèŠ‚å¥**ï¼šä¸»åˆ†æ”¯ä¿æŒå¯å‘å¸ƒï¼›æŒ‰æœˆå‘å¸ƒ betaï¼ŒæŒ‰å­£åº¦å‘å¸ƒ stableï¼›å‘å¸ƒè¯´æ˜å« Breaking/Features/Fixesï¼›ç»´æŠ¤å˜æ›´æ—¥å¿—ã€‚
* **å¤šç«¯å‘è¡Œç‰©**ï¼š
  * æ¡Œé¢ï¼šTauri bundleï¼ˆWin/MSIã€macOS dmgã€AppImage/DEB/RPMï¼‰ã€‚
  * Webï¼šPWA + wasm åŒ…ï¼›æä¾›çº¿ä¸Š Demo ä¸ self-host éƒ¨ç½²æŒ‡å¼•ã€‚
  * ç§»åŠ¨ï¼šAndroid APK/AABï¼ŒiOS TestFlightï¼›åŒä¸€ Rust æ ¸å¿ƒã€‚
* **åŒ…ç®¡ç†/é•œåƒ**ï¼šå¦‚éœ€ CLI/åº“å‘å¸ƒï¼Œæ¨ crates.ioï¼›æä¾› Docker é•œåƒï¼ˆå¸¦å¥åº·æ£€æŸ¥ï¼‰ï¼›ç”Ÿæˆ SBOM ä¾›ç”¨æˆ·å®¡è®¡ã€‚
* **éšç§ä¸é¥æµ‹**ï¼šé»˜è®¤å…³é—­é¥æµ‹ï¼Œæä¾›æ˜¾å¼ opt-inï¼›å¦‚å¯ç”¨ï¼Œè®°å½•æœ€ä½é™åº¦çš„åŒ¿åæ€§èƒ½/å´©æºƒæ•°æ®ï¼Œå¹¶å…¬å¼€æ•°æ®å­—æ®µä¸ç”¨é€”ã€‚
* **å®‰å…¨å“åº”**ï¼šæä¾›å®‰å…¨é‚®ä»¶/ç§æŠ¥æ¸ é“ï¼›è®¾ç«‹ embargo æµç¨‹ä¸è¡¥ä¸å‘å¸ƒèŠ‚å¥ã€‚

### è·å–ä¸å®‰è£…ï¼ˆé¢å‘ç”¨æˆ·ï¼‰

æœ¬èŠ‚æè¿°â€œå‘å¸ƒåˆ° GitHub åï¼Œç”¨æˆ·å¦‚ä½•æ‹‰å–/å®‰è£… Deve-Note ä¸æ’ä»¶â€ã€‚è¯¥éƒ¨åˆ†å±äºå‘å¸ƒè§„èŒƒï¼šå®ç°å¯ä»¥é€æ­¥åˆ°ä½ï¼Œä½†å‘å¸ƒç‰©çš„å‘½åä¸ç›®å½•çº¦å®š SHOULD ç¨³å®šã€‚

* **GitHub Releasesï¼ˆäºŒè¿›åˆ¶ç›´è£…ï¼‰**ï¼š
	* æ¯ä¸ªç‰ˆæœ¬ SHOULD åœ¨ GitHub Releases æä¾›ï¼šæœåŠ¡ç«¯äºŒè¿›åˆ¶ï¼ˆserver/cliï¼‰ã€æ¡Œé¢å®‰è£…åŒ…ã€`SHA256SUMS`ï¼ˆæˆ–ç­‰ä»·æ ¡éªŒæ–‡ä»¶ï¼‰ã€‚
	* ç”¨æˆ·ä¸‹è½½å SHOULD æ ¡éªŒå“ˆå¸Œå†è¿è¡Œï¼›Windows å¯ç”¨ `CertUtil -hashfile <file> SHA256`ï¼ŒLinux/macOS å¯ç”¨ `sha256sum`ã€‚
	* ç‰ˆæœ¬å·ä¸æ„å»ºä¿¡æ¯ SHOULD å¯åœ¨ `deve-note --version`ï¼ˆæˆ–ç­‰ä»·å‘½ä»¤ï¼‰ä¸­æŸ¥è¯¢ï¼Œä¾¿äºæ’éšœã€‚

* **Docker é•œåƒï¼ˆè‡ªéƒ¨ç½²æ¨èï¼‰**ï¼š
	* é•œåƒ SHOULD å‘å¸ƒåˆ° GitHub Container Registryï¼ˆGHCRï¼‰ï¼Œå¹¶æä¾›ç¨³å®šæ ‡ç­¾ï¼š`latest`ã€`vX.Y.Z`ã€‚
	* é•œåƒå¯åŠ¨æ—¶ MUST æ”¯æŒå°†æ•°æ®ç›®å½•æŒ‚è½½å‡ºæ¥ï¼ˆè‡³å°‘ `ledger` ä¸ `vault`ï¼‰ï¼Œä»¥ä¿è¯å‡çº§/è¿ç§»å®‰å…¨ã€‚
	* `docker compose` ç¤ºä¾‹ï¼ˆè·¯å¾„ä¸é•œåƒåä»¥å®é™…ä»“åº“ä¸ºå‡†ï¼‰ï¼š
	
	```yaml
	services:
	  deve-note:
	    image: ghcr.io/develeta/deve-note:vX.Y.Z
	    ports:
	      - "28000:28000"
	    volumes:
	      - ./data/ledger:/data/ledger
	      - ./data/vault:/data/vault
	      - ./data/plugins:/data/plugins
	    environment:
	      - DEVE_NOTE_PROFILE=low-spec  # Enable 512MB mode (Disable SSR, etc)
	      - DEVE_NOTE_USER=<username>
	      - DEVE_NOTE_PASSWORD_HASH=<argon2-hash>
	    deploy:
	      resources:
	        limits:
	          memory: 450M # Reserve buffer for OS
	    restart: unless-stopped
	```

* **æ’ä»¶ä¸‹è½½ä¸å®‰è£…**ï¼š
	* å‘å¸ƒæ—¶ SHOULD æä¾›â€œå®˜æ–¹æ’ä»¶ç´¢å¼•â€ï¼ˆä¾‹å¦‚ä»“åº“å†… `plugins/` æˆ–ç‹¬ç«‹ `deve-note-plugins` ä»“åº“ï¼‰ï¼Œæ¯ä¸ªæ’ä»¶åŒ…å«ï¼šæ’ä»¶åŒ…ã€ç‰ˆæœ¬å·ã€èƒ½åŠ›æ¸…å•ã€`SHA256` æ ¡éªŒã€‚
	* å®‰è£…æ–¹å¼ MUST æ”¯æŒç¦»çº¿ï¼šç”¨æˆ·å¯ç›´æ¥å°†æ’ä»¶åŒ…æ”¾å…¥æ’ä»¶ç›®å½•ï¼ˆä¾‹å¦‚ `/data/plugins/<plugin-id>/`ï¼‰ï¼Œé‡å¯æˆ–çƒ­åŠ è½½åç”Ÿæ•ˆã€‚
	* è‹¥æä¾›æ’ä»¶ç®¡ç†å‘½ä»¤ï¼Œåˆ™ SHOULD å…·å¤‡æœ€å°é›†åˆï¼š
		* `deve-note plugin list`
		* `deve-note plugin install <url|id>`ï¼ˆä¸‹è½½ + æ ¡éªŒ + è§£åŒ…åˆ°æ’ä»¶ç›®å½•ï¼‰
		* `deve-note plugin uninstall <id>`
		* `deve-note plugin enable/disable <id>`
	* æ’ä»¶å®‰è£…ä¸æ›´æ–° MUST ä¸æ”¹å˜æ ¸å¿ƒæ•°æ®è¯­ä¹‰ï¼šæ’ä»¶åªèƒ½é€šè¿‡ Host Functions + Capability å—æ§åœ°è¯»å†™ Ledger/Vault/èµ„äº§ã€‚
</file>

<file path="deve-note schedule.md">
# Deve-Note å¼€å‘è®¡åˆ’è¡¨

**é¢„è®¡æ€»æ—¶é•¿**: 8-12 å‘¨
**å¼€å§‹æ—¥æœŸ**: å¾…å®š

## é˜¶æ®µ 0: é’¢é“æ ¸å¿ƒ (Headless Prototype)
**æ—¶é•¿**: ç¬¬ 1-2 å‘¨ (å…³é”®è·¯å¾„)
**ç›®æ ‡**: åœ¨æ²¡æœ‰ä»»ä½• UI çš„æƒ…å†µä¸‹ï¼ŒéªŒè¯ "Ledger -> Vault" å’Œ "Vault -> Ledger" çš„åŒå‘åŒæ­¥é—­ç¯ã€‚**å¿…é¡»**åœ¨å¼€å§‹ UI å·¥ä½œå‰å®Œæˆã€‚

- [ ] **æ ¸å¿ƒé€»è¾‘**: æ­å»º Rust Workspace, å®ç° `Ledger` ç»“æ„ä½“ (Redb + CRDT/Loro)ã€‚
- [ ] **VFS å±‚**: å®ç° `DocId` åˆ†é…ä¸è·¯å¾„æ˜ å°„ (Path Mapping) é€»è¾‘ã€‚
- [ ] **å’Œè§£å¼•æ“ (Reconciliation Engine)**:
    - [ ] å®ç° `notify` æ–‡ä»¶ç›‘å¬å™¨ã€‚
    - [ ] **å…³é”®**: å®ç° Inode è¿½è¸ªä¸é˜²æŠ– (Debounce) é€»è¾‘ã€‚
    - [ ] **å…³é”®**: å®ç° "Diff-to-Ops" é€»è¾‘ (Dissimilar)ã€‚
- [ ] **CLI å·¥å…·**: æ„å»º `deve-note init`, `deve-note watch`, `deve-note append` å‘½ä»¤ã€‚
- [ ] **éªŒè¯åŠå…¶éªŒæ”¶**:
    - [ ] æµ‹è¯•: `VS Code` ä¿®æ”¹æ–‡ä»¶ -> `Ledger` æ­£ç¡®è®°å½• Opã€‚
    - [ ] æµ‹è¯•: `Ledger` æ¥æ”¶ Op -> `Vault` æ–‡ä»¶æ›´æ–° (ä¸”ä¸ç ´åç”¨æˆ·å…‰æ ‡/ä¸é€ æˆå†²çª)ã€‚
    - [ ] æµ‹è¯•: åœ¨ OS ä¸­é‡å‘½åæ–‡ä»¶ -> `Ledger` ä¿æŒ `DocId` ä¸å˜ (ä¸è¯¯åˆ¤ä¸ºåˆ é™¤+æ–°å»º)ã€‚

## é˜¶æ®µ 1: æœ€å°å¯è¡Œé©¾é©¶èˆ± (MVC)
**æ—¶é•¿**: ç¬¬ 3-5 å‘¨
**ç›®æ ‡**: ä¸€ä¸ªå¯ç”¨çš„æœ¬åœ° Markdown ç¼–è¾‘å™¨ï¼Œå…·å¤‡åŸºæœ¬å¯¼èˆªåŠŸèƒ½ã€‚

- [ ] **å‰ç«¯åŸºç¡€è®¾æ–½**:
    - [ ] åˆå§‹åŒ– Leptos v0.7 + Tailwind CSS é¡¹ç›®ã€‚
    - [ ] å®ç° "Resizable Slots" (å¯ç¼©æ”¾æ’æ§½) å¸ƒå±€å¼•æ“ã€‚
- [ ] **ç¼–è¾‘å™¨é›†æˆ**:
    - [ ] å°† CodeMirror 6 å°è£…ä¸º Leptos ç»„ä»¶ã€‚
    - [ ] å°† CodeMirror å˜æ›´ç»‘å®šåˆ° Loro CRDT (Wasm)ã€‚
    - [ ] å®ç°åŸºç¡€ Markdown æ ·å¼æ¸²æŸ“ä¸æ•°å­¦å…¬å¼ (KaTeX/MathJax) æ”¯æŒã€‚
- [ ] **æœåŠ¡ç«¯é€šä¿¡**:
    - [ ] å®ç°å…·å¤‡æ–­çº¿é‡è¿é€»è¾‘çš„ WebSocket å®¢æˆ·ç«¯ã€‚
    - [ ] å®ç° "æ–‡ä»¶æ ‘" ä¾§è¾¹æ  (è™šæ‹Ÿåˆ—è¡¨)ã€‚

## é˜¶æ®µ 2: é²æ£’æ€§å¼ºåŒ– ("512MB æŒ‘æˆ˜")
**æ—¶é•¿**: ç¬¬ 6-7 å‘¨
**ç›®æ ‡**: é’ˆå¯¹ä½é…æœåŠ¡å™¨è¿›è¡Œä¼˜åŒ–ï¼Œå¹¶ç¡®ä¿æ•°æ®å®‰å…¨ã€‚

- [ ] **æ€§èƒ½ä¼˜åŒ–**:
    - [ ] å®ç° `DEVE_PROFILE` é…ç½®åŠ è½½é€»è¾‘ã€‚
    - [ ] ä¸º `low-spec` æ¨¡å¼å®ç°ä»… CSR (å®¢æˆ·ç«¯æ¸²æŸ“) æ¨¡å¼ã€‚
    - [ ] å†…å­˜åˆ†æä¸ä¼˜åŒ– (è®¾ç½®ç¼“å­˜ä¸Šé™)ã€‚
- [ ] **æ•°æ®å®‰å…¨**:
    - [ ] å®ç°å®šæœŸå¿«ç…§ (Snapshotting) ä¸è£å‰ª (Pruning) ç­–ç•¥ (ä½é…æ¨¡å¼ä¿ç•™ 10 ä¸ªå¿«ç…§)ã€‚
    - [ ] å®ç° `deve-note export-ledger` (å¯¼å‡º JSONL) ç¾å¤‡åŠŸèƒ½ã€‚
    - [ ] å‹åŠ›æµ‹è¯•: æµ‹è¯•ç½‘ç»œæ–­å¼€å’ŒæœåŠ¡å™¨å¼ºåˆ¶æ€è¿›ç¨‹åœºæ™¯ä¸‹çš„æ•°æ®å®Œæ•´æ€§ã€‚

## é˜¶æ®µ 3: æ’ä»¶ä¸é«˜çº§èƒ½åŠ›
**æ—¶é•¿**: ç¬¬ 8-10 å‘¨
**ç›®æ ‡**: å¯ç”¨æ‰©å±•æ€§ä¸ä¸°å¯ŒåŠŸèƒ½ (æœç´¢, å›¾è°±)ã€‚

- [ ] **æ’ä»¶ç³»ç»Ÿ**:
    - [ ] é›†æˆ `Rhai` æˆ– `Extism` è¿è¡Œæ—¶ã€‚
    - [ ] å®ç° `Capability` (èƒ½åŠ›æ¸…å•) è§£æå™¨ä¸æ‰§è¡Œå™¨ã€‚
- [ ] **å®¿ä¸»å‡½æ•° (Host Functions)**:
    - [ ] æš´éœ² `read_note`, `write_note` (å—æ§ API)ã€‚
    - [ ] å®ç° `Plugin RPC Bridge` (å‰ç«¯ <-> åç«¯é€šä¿¡æ¡¥æ¢)ã€‚
- [ ] **é«˜çº§ç‰¹æ€§** (ä»… Standard Profile):
    - [ ] é›†æˆ `Tantivy` å®ç°å…¨æ–‡æ£€ç´¢ã€‚
    - [ ] å®ç°åå°å›¾è°±åˆ†æä¸å¯è§†åŒ–åŠŸèƒ½ã€‚

## é˜¶æ®µ 4: æ‰“ç£¨ä¸å‘å¸ƒ
**æ—¶é•¿**: ç¬¬ 11-12 å‘¨
**ç›®æ ‡**: å‡†å¤‡å…¬å¼€å‘å¸ƒã€‚

- [ ] **CI/CD**:
    - [ ] é…ç½® GitHub Actions è¿›è¡Œäº¤å‰ç¼–è¯‘ (ç”Ÿæˆ Windows/Linux/macOS äºŒè¿›åˆ¶)ã€‚
    - [ ] æ„å»º Docker é•œåƒ (æ”¯æŒ Standard & Low-Spec profiles)ã€‚
- [ ] **ç§»åŠ¨ç«¯**:
    - [ ] ä¸ºç§»åŠ¨ç«¯å¤–å£³æ„å»ºç®€åŒ–çš„ "é˜…è¯»æ¨¡å¼ (Reader Mode)" UIã€‚
- [ ] **æ–‡æ¡£**:
    - [ ] ç¼–å†™ `README.md` å’Œç”¨æˆ·æŒ‡å— (User Guide)ã€‚
    - [ ] ç¼–å†™æ’ä»¶ API æ–‡æ¡£ã€‚
- [ ] **å‘å¸ƒ**: å‘å¸ƒ v0.1.0 Beta ç‰ˆæœ¬ã€‚
</file>

</files>
